// automatically generated by the FlatBuffers compiler, do not modify

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum Any {
  NONE = 0,
  Accept = 1,
  ApplySourceMap = 2,
  Cache = 3,
  Chdir = 4,
  Chmod = 5,
  Chown = 6,
  Close = 7,
  CopyFile = 8,
  CreateWorker = 9,
  CreateWorkerRes = 10,
  Cwd = 11,
  CwdRes = 12,
  Dial = 13,
  Environ = 14,
  EnvironRes = 15,
  Exit = 16,
  Fetch = 17,
  FetchSourceFile = 18,
  FetchSourceFileRes = 19,
  FetchRes = 20,
  FormatError = 21,
  FormatErrorRes = 22,
  GetRandomValues = 23,
  GlobalTimer = 24,
  GlobalTimerRes = 25,
  GlobalTimerStop = 26,
  HostGetMessage = 27,
  HostGetMessageRes = 28,
  HostGetWorkerClosed = 29,
  HostPostMessage = 30,
  IsTTY = 31,
  IsTTYRes = 32,
  Kill = 33,
  Link = 34,
  Listen = 35,
  ListenRes = 36,
  MakeTempDir = 37,
  MakeTempDirRes = 38,
  Metrics = 39,
  MetricsRes = 40,
  Mkdir = 41,
  NewConn = 42,
  Now = 43,
  NowRes = 44,
  Open = 45,
  OpenRes = 46,
  PermissionRevoke = 47,
  Permissions = 48,
  PermissionsRes = 49,
  Read = 50,
  ReadDir = 51,
  ReadDirRes = 52,
  ReadRes = 53,
  Readlink = 54,
  ReadlinkRes = 55,
  Remove = 56,
  Rename = 57,
  ReplReadline = 58,
  ReplReadlineRes = 59,
  ReplStart = 60,
  ReplStartRes = 61,
  Resources = 62,
  ResourcesRes = 63,
  Run = 64,
  RunRes = 65,
  RunStatus = 66,
  RunStatusRes = 67,
  Seek = 68,
  SetEnv = 69,
  Shutdown = 70,
  Start = 71,
  StartRes = 72,
  Stat = 73,
  StatRes = 74,
  Symlink = 75,
  Truncate = 76,
  HomeDir = 77,
  HomeDirRes = 78,
  ExecPath = 79,
  ExecPathRes = 80,
  Utime = 81,
  WorkerGetMessage = 82,
  WorkerGetMessageRes = 83,
  WorkerPostMessage = 84,
  Write = 85,
  WriteRes = 86,
}

const ENUM_MIN_ANY: u8 = 0;
const ENUM_MAX_ANY: u8 = 86;

impl<'a> flatbuffers::Follow<'a> for Any {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Any {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Any;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Any;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Any {
  type Output = Any;
  #[inline]
  fn push(&self, dst: &mut [u8], _rest: &[u8]) {
    flatbuffers::emplace_scalar::<Any>(dst, *self);
  }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_ANY: [Any; 87] = [
  Any::NONE,
  Any::Accept,
  Any::ApplySourceMap,
  Any::Cache,
  Any::Chdir,
  Any::Chmod,
  Any::Chown,
  Any::Close,
  Any::CopyFile,
  Any::CreateWorker,
  Any::CreateWorkerRes,
  Any::Cwd,
  Any::CwdRes,
  Any::Dial,
  Any::Environ,
  Any::EnvironRes,
  Any::Exit,
  Any::Fetch,
  Any::FetchSourceFile,
  Any::FetchSourceFileRes,
  Any::FetchRes,
  Any::FormatError,
  Any::FormatErrorRes,
  Any::GetRandomValues,
  Any::GlobalTimer,
  Any::GlobalTimerRes,
  Any::GlobalTimerStop,
  Any::HostGetMessage,
  Any::HostGetMessageRes,
  Any::HostGetWorkerClosed,
  Any::HostPostMessage,
  Any::IsTTY,
  Any::IsTTYRes,
  Any::Kill,
  Any::Link,
  Any::Listen,
  Any::ListenRes,
  Any::MakeTempDir,
  Any::MakeTempDirRes,
  Any::Metrics,
  Any::MetricsRes,
  Any::Mkdir,
  Any::NewConn,
  Any::Now,
  Any::NowRes,
  Any::Open,
  Any::OpenRes,
  Any::PermissionRevoke,
  Any::Permissions,
  Any::PermissionsRes,
  Any::Read,
  Any::ReadDir,
  Any::ReadDirRes,
  Any::ReadRes,
  Any::Readlink,
  Any::ReadlinkRes,
  Any::Remove,
  Any::Rename,
  Any::ReplReadline,
  Any::ReplReadlineRes,
  Any::ReplStart,
  Any::ReplStartRes,
  Any::Resources,
  Any::ResourcesRes,
  Any::Run,
  Any::RunRes,
  Any::RunStatus,
  Any::RunStatusRes,
  Any::Seek,
  Any::SetEnv,
  Any::Shutdown,
  Any::Start,
  Any::StartRes,
  Any::Stat,
  Any::StatRes,
  Any::Symlink,
  Any::Truncate,
  Any::HomeDir,
  Any::HomeDirRes,
  Any::ExecPath,
  Any::ExecPathRes,
  Any::Utime,
  Any::WorkerGetMessage,
  Any::WorkerGetMessageRes,
  Any::WorkerPostMessage,
  Any::Write,
  Any::WriteRes,
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_ANY: [&'static str; 87] = [
  "NONE",
  "Accept",
  "ApplySourceMap",
  "Cache",
  "Chdir",
  "Chmod",
  "Chown",
  "Close",
  "CopyFile",
  "CreateWorker",
  "CreateWorkerRes",
  "Cwd",
  "CwdRes",
  "Dial",
  "Environ",
  "EnvironRes",
  "Exit",
  "Fetch",
  "FetchSourceFile",
  "FetchSourceFileRes",
  "FetchRes",
  "FormatError",
  "FormatErrorRes",
  "GetRandomValues",
  "GlobalTimer",
  "GlobalTimerRes",
  "GlobalTimerStop",
  "HostGetMessage",
  "HostGetMessageRes",
  "HostGetWorkerClosed",
  "HostPostMessage",
  "IsTTY",
  "IsTTYRes",
  "Kill",
  "Link",
  "Listen",
  "ListenRes",
  "MakeTempDir",
  "MakeTempDirRes",
  "Metrics",
  "MetricsRes",
  "Mkdir",
  "NewConn",
  "Now",
  "NowRes",
  "Open",
  "OpenRes",
  "PermissionRevoke",
  "Permissions",
  "PermissionsRes",
  "Read",
  "ReadDir",
  "ReadDirRes",
  "ReadRes",
  "Readlink",
  "ReadlinkRes",
  "Remove",
  "Rename",
  "ReplReadline",
  "ReplReadlineRes",
  "ReplStart",
  "ReplStartRes",
  "Resources",
  "ResourcesRes",
  "Run",
  "RunRes",
  "RunStatus",
  "RunStatusRes",
  "Seek",
  "SetEnv",
  "Shutdown",
  "Start",
  "StartRes",
  "Stat",
  "StatRes",
  "Symlink",
  "Truncate",
  "HomeDir",
  "HomeDirRes",
  "ExecPath",
  "ExecPathRes",
  "Utime",
  "WorkerGetMessage",
  "WorkerGetMessageRes",
  "WorkerPostMessage",
  "Write",
  "WriteRes",
];

pub fn enum_name_any(e: Any) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_ANY[index]
}

pub struct AnyUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum ErrorKind {
  NoError = 0,
  NotFound = 1,
  PermissionDenied = 2,
  ConnectionRefused = 3,
  ConnectionReset = 4,
  ConnectionAborted = 5,
  NotConnected = 6,
  AddrInUse = 7,
  AddrNotAvailable = 8,
  BrokenPipe = 9,
  AlreadyExists = 10,
  WouldBlock = 11,
  InvalidInput = 12,
  InvalidData = 13,
  TimedOut = 14,
  Interrupted = 15,
  WriteZero = 16,
  Other = 17,
  UnexpectedEof = 18,
  BadResource = 19,
  CommandFailed = 20,
  EmptyHost = 21,
  IdnaError = 22,
  InvalidPort = 23,
  InvalidIpv4Address = 24,
  InvalidIpv6Address = 25,
  InvalidDomainCharacter = 26,
  RelativeUrlWithoutBase = 27,
  RelativeUrlWithCannotBeABaseBase = 28,
  SetHostOnCannotBeABaseUrl = 29,
  Overflow = 30,
  HttpUser = 31,
  HttpClosed = 32,
  HttpCanceled = 33,
  HttpParse = 34,
  HttpOther = 35,
  TooLarge = 36,
  InvalidUri = 37,
  InvalidSeekMode = 38,
  OpNotAvailable = 39,
  WorkerInitFailed = 40,
  UnixError = 41,
  NoAsyncSupport = 42,
  NoSyncSupport = 43,
  ImportMapError = 44,
  InvalidPath = 45,
  ImportPrefixMissing = 46,
  UnsupportedFetchScheme = 47,
  TooManyRedirects = 48,
  Diagnostic = 49,
  JSError = 50,
}

const ENUM_MIN_ERROR_KIND: i8 = 0;
const ENUM_MAX_ERROR_KIND: i8 = 50;

impl<'a> flatbuffers::Follow<'a> for ErrorKind {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for ErrorKind {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const ErrorKind;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const ErrorKind;
    unsafe { *p }
  }
}

impl flatbuffers::Push for ErrorKind {
  type Output = ErrorKind;
  #[inline]
  fn push(&self, dst: &mut [u8], _rest: &[u8]) {
    flatbuffers::emplace_scalar::<ErrorKind>(dst, *self);
  }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_ERROR_KIND: [ErrorKind; 51] = [
  ErrorKind::NoError,
  ErrorKind::NotFound,
  ErrorKind::PermissionDenied,
  ErrorKind::ConnectionRefused,
  ErrorKind::ConnectionReset,
  ErrorKind::ConnectionAborted,
  ErrorKind::NotConnected,
  ErrorKind::AddrInUse,
  ErrorKind::AddrNotAvailable,
  ErrorKind::BrokenPipe,
  ErrorKind::AlreadyExists,
  ErrorKind::WouldBlock,
  ErrorKind::InvalidInput,
  ErrorKind::InvalidData,
  ErrorKind::TimedOut,
  ErrorKind::Interrupted,
  ErrorKind::WriteZero,
  ErrorKind::Other,
  ErrorKind::UnexpectedEof,
  ErrorKind::BadResource,
  ErrorKind::CommandFailed,
  ErrorKind::EmptyHost,
  ErrorKind::IdnaError,
  ErrorKind::InvalidPort,
  ErrorKind::InvalidIpv4Address,
  ErrorKind::InvalidIpv6Address,
  ErrorKind::InvalidDomainCharacter,
  ErrorKind::RelativeUrlWithoutBase,
  ErrorKind::RelativeUrlWithCannotBeABaseBase,
  ErrorKind::SetHostOnCannotBeABaseUrl,
  ErrorKind::Overflow,
  ErrorKind::HttpUser,
  ErrorKind::HttpClosed,
  ErrorKind::HttpCanceled,
  ErrorKind::HttpParse,
  ErrorKind::HttpOther,
  ErrorKind::TooLarge,
  ErrorKind::InvalidUri,
  ErrorKind::InvalidSeekMode,
  ErrorKind::OpNotAvailable,
  ErrorKind::WorkerInitFailed,
  ErrorKind::UnixError,
  ErrorKind::NoAsyncSupport,
  ErrorKind::NoSyncSupport,
  ErrorKind::ImportMapError,
  ErrorKind::InvalidPath,
  ErrorKind::ImportPrefixMissing,
  ErrorKind::UnsupportedFetchScheme,
  ErrorKind::TooManyRedirects,
  ErrorKind::Diagnostic,
  ErrorKind::JSError,
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_ERROR_KIND: [&'static str; 51] = [
  "NoError",
  "NotFound",
  "PermissionDenied",
  "ConnectionRefused",
  "ConnectionReset",
  "ConnectionAborted",
  "NotConnected",
  "AddrInUse",
  "AddrNotAvailable",
  "BrokenPipe",
  "AlreadyExists",
  "WouldBlock",
  "InvalidInput",
  "InvalidData",
  "TimedOut",
  "Interrupted",
  "WriteZero",
  "Other",
  "UnexpectedEof",
  "BadResource",
  "CommandFailed",
  "EmptyHost",
  "IdnaError",
  "InvalidPort",
  "InvalidIpv4Address",
  "InvalidIpv6Address",
  "InvalidDomainCharacter",
  "RelativeUrlWithoutBase",
  "RelativeUrlWithCannotBeABaseBase",
  "SetHostOnCannotBeABaseUrl",
  "Overflow",
  "HttpUser",
  "HttpClosed",
  "HttpCanceled",
  "HttpParse",
  "HttpOther",
  "TooLarge",
  "InvalidUri",
  "InvalidSeekMode",
  "OpNotAvailable",
  "WorkerInitFailed",
  "UnixError",
  "NoAsyncSupport",
  "NoSyncSupport",
  "ImportMapError",
  "InvalidPath",
  "ImportPrefixMissing",
  "UnsupportedFetchScheme",
  "TooManyRedirects",
  "Diagnostic",
  "JSError",
];

pub fn enum_name_error_kind(e: ErrorKind) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_ERROR_KIND[index]
}

#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum MediaType {
  JavaScript = 0,
  TypeScript = 1,
  Json = 2,
  Unknown = 3,
}

const ENUM_MIN_MEDIA_TYPE: i8 = 0;
const ENUM_MAX_MEDIA_TYPE: i8 = 3;

impl<'a> flatbuffers::Follow<'a> for MediaType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for MediaType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const MediaType;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const MediaType;
    unsafe { *p }
  }
}

impl flatbuffers::Push for MediaType {
  type Output = MediaType;
  #[inline]
  fn push(&self, dst: &mut [u8], _rest: &[u8]) {
    flatbuffers::emplace_scalar::<MediaType>(dst, *self);
  }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_MEDIA_TYPE: [MediaType; 4] = [
  MediaType::JavaScript,
  MediaType::TypeScript,
  MediaType::Json,
  MediaType::Unknown,
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_MEDIA_TYPE: [&'static str; 4] =
  ["JavaScript", "TypeScript", "Json", "Unknown"];

pub fn enum_name_media_type(e: MediaType) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_MEDIA_TYPE[index]
}

#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum ProcessStdio {
  Inherit = 0,
  Piped = 1,
  Null = 2,
}

const ENUM_MIN_PROCESS_STDIO: i8 = 0;
const ENUM_MAX_PROCESS_STDIO: i8 = 2;

impl<'a> flatbuffers::Follow<'a> for ProcessStdio {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for ProcessStdio {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const ProcessStdio;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const ProcessStdio;
    unsafe { *p }
  }
}

impl flatbuffers::Push for ProcessStdio {
  type Output = ProcessStdio;
  #[inline]
  fn push(&self, dst: &mut [u8], _rest: &[u8]) {
    flatbuffers::emplace_scalar::<ProcessStdio>(dst, *self);
  }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_PROCESS_STDIO: [ProcessStdio; 3] = [
  ProcessStdio::Inherit,
  ProcessStdio::Piped,
  ProcessStdio::Null,
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_PROCESS_STDIO: [&'static str; 3] =
  ["Inherit", "Piped", "Null"];

pub fn enum_name_process_stdio(e: ProcessStdio) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_PROCESS_STDIO[index]
}

pub enum CwdOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Cwd<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Cwd<'a> {
  type Inner = Cwd<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Cwd<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Cwd { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args CwdArgs,
  ) -> flatbuffers::WIPOffset<Cwd<'bldr>> {
    let mut builder = CwdBuilder::new(_fbb);
    builder.finish()
  }
}

pub struct CwdArgs {}
impl<'a> Default for CwdArgs {
  #[inline]
  fn default() -> Self {
    CwdArgs {}
  }
}
pub struct CwdBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CwdBuilder<'a, 'b> {
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> CwdBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CwdBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Cwd<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum CwdResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CwdRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CwdRes<'a> {
  type Inner = CwdRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> CwdRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CwdRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CwdResArgs<'args>,
  ) -> flatbuffers::WIPOffset<CwdRes<'bldr>> {
    let mut builder = CwdResBuilder::new(_fbb);
    if let Some(x) = args.cwd {
      builder.add_cwd(x);
    }
    builder.finish()
  }

  pub const VT_CWD: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn cwd(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(CwdRes::VT_CWD, None)
  }
}

pub struct CwdResArgs<'a> {
  pub cwd: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CwdResArgs<'a> {
  #[inline]
  fn default() -> Self {
    CwdResArgs { cwd: None }
  }
}
pub struct CwdResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CwdResBuilder<'a, 'b> {
  #[inline]
  pub fn add_cwd(&mut self, cwd: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(CwdRes::VT_CWD, cwd);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> CwdResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CwdResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CwdRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BaseOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Base<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Base<'a> {
  type Inner = Base<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Base<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Base { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BaseArgs<'args>,
  ) -> flatbuffers::WIPOffset<Base<'bldr>> {
    let mut builder = BaseBuilder::new(_fbb);
    if let Some(x) = args.inner {
      builder.add_inner(x);
    }
    if let Some(x) = args.error {
      builder.add_error(x);
    }
    builder.add_cmd_id(args.cmd_id);
    builder.add_inner_type(args.inner_type);
    builder.add_error_kind(args.error_kind);
    builder.add_sync(args.sync);
    builder.finish()
  }

  pub const VT_CMD_ID: flatbuffers::VOffsetT = 4;
  pub const VT_SYNC: flatbuffers::VOffsetT = 6;
  pub const VT_ERROR_KIND: flatbuffers::VOffsetT = 8;
  pub const VT_ERROR: flatbuffers::VOffsetT = 10;
  pub const VT_INNER_TYPE: flatbuffers::VOffsetT = 12;
  pub const VT_INNER: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn cmd_id(&self) -> u32 {
    self._tab.get::<u32>(Base::VT_CMD_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn sync(&self) -> bool {
    self._tab.get::<bool>(Base::VT_SYNC, Some(false)).unwrap()
  }
  #[inline]
  pub fn error_kind(&self) -> ErrorKind {
    self
      ._tab
      .get::<ErrorKind>(Base::VT_ERROR_KIND, Some(ErrorKind::NoError))
      .unwrap()
  }
  #[inline]
  pub fn error(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Base::VT_ERROR, None)
  }
  #[inline]
  pub fn inner_type(&self) -> Any {
    self
      ._tab
      .get::<Any>(Base::VT_INNER_TYPE, Some(Any::NONE))
      .unwrap()
  }
  #[inline]
  pub fn inner(&self) -> Option<flatbuffers::Table<'a>> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
        Base::VT_INNER,
        None,
      )
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_accept(&'a self) -> Option<Accept> {
    if self.inner_type() == Any::Accept {
      self.inner().map(|u| Accept::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_apply_source_map(&'a self) -> Option<ApplySourceMap> {
    if self.inner_type() == Any::ApplySourceMap {
      self.inner().map(|u| ApplySourceMap::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_cache(&'a self) -> Option<Cache> {
    if self.inner_type() == Any::Cache {
      self.inner().map(|u| Cache::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_chdir(&'a self) -> Option<Chdir> {
    if self.inner_type() == Any::Chdir {
      self.inner().map(|u| Chdir::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_chmod(&'a self) -> Option<Chmod> {
    if self.inner_type() == Any::Chmod {
      self.inner().map(|u| Chmod::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_chown(&'a self) -> Option<Chown> {
    if self.inner_type() == Any::Chown {
      self.inner().map(|u| Chown::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_close(&'a self) -> Option<Close> {
    if self.inner_type() == Any::Close {
      self.inner().map(|u| Close::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_copy_file(&'a self) -> Option<CopyFile> {
    if self.inner_type() == Any::CopyFile {
      self.inner().map(|u| CopyFile::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_create_worker(&'a self) -> Option<CreateWorker> {
    if self.inner_type() == Any::CreateWorker {
      self.inner().map(|u| CreateWorker::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_create_worker_res(&'a self) -> Option<CreateWorkerRes> {
    if self.inner_type() == Any::CreateWorkerRes {
      self.inner().map(|u| CreateWorkerRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_cwd(&'a self) -> Option<Cwd> {
    if self.inner_type() == Any::Cwd {
      self.inner().map(|u| Cwd::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_cwd_res(&'a self) -> Option<CwdRes> {
    if self.inner_type() == Any::CwdRes {
      self.inner().map(|u| CwdRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_dial(&'a self) -> Option<Dial> {
    if self.inner_type() == Any::Dial {
      self.inner().map(|u| Dial::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_environ(&'a self) -> Option<Environ> {
    if self.inner_type() == Any::Environ {
      self.inner().map(|u| Environ::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_environ_res(&'a self) -> Option<EnvironRes> {
    if self.inner_type() == Any::EnvironRes {
      self.inner().map(|u| EnvironRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_exit(&'a self) -> Option<Exit> {
    if self.inner_type() == Any::Exit {
      self.inner().map(|u| Exit::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_fetch(&'a self) -> Option<Fetch> {
    if self.inner_type() == Any::Fetch {
      self.inner().map(|u| Fetch::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_fetch_source_file(&'a self) -> Option<FetchSourceFile> {
    if self.inner_type() == Any::FetchSourceFile {
      self.inner().map(|u| FetchSourceFile::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_fetch_source_file_res(
    &'a self,
  ) -> Option<FetchSourceFileRes> {
    if self.inner_type() == Any::FetchSourceFileRes {
      self.inner().map(|u| FetchSourceFileRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_fetch_res(&'a self) -> Option<FetchRes> {
    if self.inner_type() == Any::FetchRes {
      self.inner().map(|u| FetchRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_format_error(&'a self) -> Option<FormatError> {
    if self.inner_type() == Any::FormatError {
      self.inner().map(|u| FormatError::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_format_error_res(&'a self) -> Option<FormatErrorRes> {
    if self.inner_type() == Any::FormatErrorRes {
      self.inner().map(|u| FormatErrorRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_get_random_values(&'a self) -> Option<GetRandomValues> {
    if self.inner_type() == Any::GetRandomValues {
      self.inner().map(|u| GetRandomValues::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_global_timer(&'a self) -> Option<GlobalTimer> {
    if self.inner_type() == Any::GlobalTimer {
      self.inner().map(|u| GlobalTimer::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_global_timer_res(&'a self) -> Option<GlobalTimerRes> {
    if self.inner_type() == Any::GlobalTimerRes {
      self.inner().map(|u| GlobalTimerRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_global_timer_stop(&'a self) -> Option<GlobalTimerStop> {
    if self.inner_type() == Any::GlobalTimerStop {
      self.inner().map(|u| GlobalTimerStop::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_host_get_message(&'a self) -> Option<HostGetMessage> {
    if self.inner_type() == Any::HostGetMessage {
      self.inner().map(|u| HostGetMessage::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_host_get_message_res(&'a self) -> Option<HostGetMessageRes> {
    if self.inner_type() == Any::HostGetMessageRes {
      self.inner().map(|u| HostGetMessageRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_host_get_worker_closed(
    &'a self,
  ) -> Option<HostGetWorkerClosed> {
    if self.inner_type() == Any::HostGetWorkerClosed {
      self
        .inner()
        .map(|u| HostGetWorkerClosed::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_host_post_message(&'a self) -> Option<HostPostMessage> {
    if self.inner_type() == Any::HostPostMessage {
      self.inner().map(|u| HostPostMessage::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_is_tty(&'a self) -> Option<IsTTY> {
    if self.inner_type() == Any::IsTTY {
      self.inner().map(|u| IsTTY::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_is_ttyres(&'a self) -> Option<IsTTYRes> {
    if self.inner_type() == Any::IsTTYRes {
      self.inner().map(|u| IsTTYRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_kill(&'a self) -> Option<Kill> {
    if self.inner_type() == Any::Kill {
      self.inner().map(|u| Kill::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_link(&'a self) -> Option<Link> {
    if self.inner_type() == Any::Link {
      self.inner().map(|u| Link::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_listen(&'a self) -> Option<Listen> {
    if self.inner_type() == Any::Listen {
      self.inner().map(|u| Listen::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_listen_res(&'a self) -> Option<ListenRes> {
    if self.inner_type() == Any::ListenRes {
      self.inner().map(|u| ListenRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_make_temp_dir(&'a self) -> Option<MakeTempDir> {
    if self.inner_type() == Any::MakeTempDir {
      self.inner().map(|u| MakeTempDir::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_make_temp_dir_res(&'a self) -> Option<MakeTempDirRes> {
    if self.inner_type() == Any::MakeTempDirRes {
      self.inner().map(|u| MakeTempDirRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_metrics(&'a self) -> Option<Metrics> {
    if self.inner_type() == Any::Metrics {
      self.inner().map(|u| Metrics::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_metrics_res(&'a self) -> Option<MetricsRes> {
    if self.inner_type() == Any::MetricsRes {
      self.inner().map(|u| MetricsRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_mkdir(&'a self) -> Option<Mkdir> {
    if self.inner_type() == Any::Mkdir {
      self.inner().map(|u| Mkdir::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_new_conn(&'a self) -> Option<NewConn> {
    if self.inner_type() == Any::NewConn {
      self.inner().map(|u| NewConn::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_now(&'a self) -> Option<Now> {
    if self.inner_type() == Any::Now {
      self.inner().map(|u| Now::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_now_res(&'a self) -> Option<NowRes> {
    if self.inner_type() == Any::NowRes {
      self.inner().map(|u| NowRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_open(&'a self) -> Option<Open> {
    if self.inner_type() == Any::Open {
      self.inner().map(|u| Open::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_open_res(&'a self) -> Option<OpenRes> {
    if self.inner_type() == Any::OpenRes {
      self.inner().map(|u| OpenRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_permission_revoke(&'a self) -> Option<PermissionRevoke> {
    if self.inner_type() == Any::PermissionRevoke {
      self.inner().map(|u| PermissionRevoke::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_permissions(&'a self) -> Option<Permissions> {
    if self.inner_type() == Any::Permissions {
      self.inner().map(|u| Permissions::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_permissions_res(&'a self) -> Option<PermissionsRes> {
    if self.inner_type() == Any::PermissionsRes {
      self.inner().map(|u| PermissionsRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_read(&'a self) -> Option<Read> {
    if self.inner_type() == Any::Read {
      self.inner().map(|u| Read::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_read_dir(&'a self) -> Option<ReadDir> {
    if self.inner_type() == Any::ReadDir {
      self.inner().map(|u| ReadDir::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_read_dir_res(&'a self) -> Option<ReadDirRes> {
    if self.inner_type() == Any::ReadDirRes {
      self.inner().map(|u| ReadDirRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_read_res(&'a self) -> Option<ReadRes> {
    if self.inner_type() == Any::ReadRes {
      self.inner().map(|u| ReadRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_readlink(&'a self) -> Option<Readlink> {
    if self.inner_type() == Any::Readlink {
      self.inner().map(|u| Readlink::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_readlink_res(&'a self) -> Option<ReadlinkRes> {
    if self.inner_type() == Any::ReadlinkRes {
      self.inner().map(|u| ReadlinkRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_remove(&'a self) -> Option<Remove> {
    if self.inner_type() == Any::Remove {
      self.inner().map(|u| Remove::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_rename(&'a self) -> Option<Rename> {
    if self.inner_type() == Any::Rename {
      self.inner().map(|u| Rename::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_repl_readline(&'a self) -> Option<ReplReadline> {
    if self.inner_type() == Any::ReplReadline {
      self.inner().map(|u| ReplReadline::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_repl_readline_res(&'a self) -> Option<ReplReadlineRes> {
    if self.inner_type() == Any::ReplReadlineRes {
      self.inner().map(|u| ReplReadlineRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_repl_start(&'a self) -> Option<ReplStart> {
    if self.inner_type() == Any::ReplStart {
      self.inner().map(|u| ReplStart::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_repl_start_res(&'a self) -> Option<ReplStartRes> {
    if self.inner_type() == Any::ReplStartRes {
      self.inner().map(|u| ReplStartRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_resources(&'a self) -> Option<Resources> {
    if self.inner_type() == Any::Resources {
      self.inner().map(|u| Resources::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_resources_res(&'a self) -> Option<ResourcesRes> {
    if self.inner_type() == Any::ResourcesRes {
      self.inner().map(|u| ResourcesRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_run(&'a self) -> Option<Run> {
    if self.inner_type() == Any::Run {
      self.inner().map(|u| Run::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_run_res(&'a self) -> Option<RunRes> {
    if self.inner_type() == Any::RunRes {
      self.inner().map(|u| RunRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_run_status(&'a self) -> Option<RunStatus> {
    if self.inner_type() == Any::RunStatus {
      self.inner().map(|u| RunStatus::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_run_status_res(&'a self) -> Option<RunStatusRes> {
    if self.inner_type() == Any::RunStatusRes {
      self.inner().map(|u| RunStatusRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_seek(&'a self) -> Option<Seek> {
    if self.inner_type() == Any::Seek {
      self.inner().map(|u| Seek::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_set_env(&'a self) -> Option<SetEnv> {
    if self.inner_type() == Any::SetEnv {
      self.inner().map(|u| SetEnv::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_shutdown(&'a self) -> Option<Shutdown> {
    if self.inner_type() == Any::Shutdown {
      self.inner().map(|u| Shutdown::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_start(&'a self) -> Option<Start> {
    if self.inner_type() == Any::Start {
      self.inner().map(|u| Start::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_start_res(&'a self) -> Option<StartRes> {
    if self.inner_type() == Any::StartRes {
      self.inner().map(|u| StartRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_stat(&'a self) -> Option<Stat> {
    if self.inner_type() == Any::Stat {
      self.inner().map(|u| Stat::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_stat_res(&'a self) -> Option<StatRes> {
    if self.inner_type() == Any::StatRes {
      self.inner().map(|u| StatRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_symlink(&'a self) -> Option<Symlink> {
    if self.inner_type() == Any::Symlink {
      self.inner().map(|u| Symlink::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_truncate(&'a self) -> Option<Truncate> {
    if self.inner_type() == Any::Truncate {
      self.inner().map(|u| Truncate::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_home_dir(&'a self) -> Option<HomeDir> {
    if self.inner_type() == Any::HomeDir {
      self.inner().map(|u| HomeDir::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_home_dir_res(&'a self) -> Option<HomeDirRes> {
    if self.inner_type() == Any::HomeDirRes {
      self.inner().map(|u| HomeDirRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_exec_path(&'a self) -> Option<ExecPath> {
    if self.inner_type() == Any::ExecPath {
      self.inner().map(|u| ExecPath::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_exec_path_res(&'a self) -> Option<ExecPathRes> {
    if self.inner_type() == Any::ExecPathRes {
      self.inner().map(|u| ExecPathRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_utime(&'a self) -> Option<Utime> {
    if self.inner_type() == Any::Utime {
      self.inner().map(|u| Utime::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_worker_get_message(&'a self) -> Option<WorkerGetMessage> {
    if self.inner_type() == Any::WorkerGetMessage {
      self.inner().map(|u| WorkerGetMessage::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_worker_get_message_res(
    &'a self,
  ) -> Option<WorkerGetMessageRes> {
    if self.inner_type() == Any::WorkerGetMessageRes {
      self
        .inner()
        .map(|u| WorkerGetMessageRes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_worker_post_message(&'a self) -> Option<WorkerPostMessage> {
    if self.inner_type() == Any::WorkerPostMessage {
      self.inner().map(|u| WorkerPostMessage::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_write(&'a self) -> Option<Write> {
    if self.inner_type() == Any::Write {
      self.inner().map(|u| Write::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn inner_as_write_res(&'a self) -> Option<WriteRes> {
    if self.inner_type() == Any::WriteRes {
      self.inner().map(|u| WriteRes::init_from_table(u))
    } else {
      None
    }
  }
}

pub struct BaseArgs<'a> {
  pub cmd_id: u32,
  pub sync: bool,
  pub error_kind: ErrorKind,
  pub error: Option<flatbuffers::WIPOffset<&'a str>>,
  pub inner_type: Any,
  pub inner: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for BaseArgs<'a> {
  #[inline]
  fn default() -> Self {
    BaseArgs {
      cmd_id: 0,
      sync: false,
      error_kind: ErrorKind::NoError,
      error: None,
      inner_type: Any::NONE,
      inner: None,
    }
  }
}
pub struct BaseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BaseBuilder<'a, 'b> {
  #[inline]
  pub fn add_cmd_id(&mut self, cmd_id: u32) {
    self.fbb_.push_slot::<u32>(Base::VT_CMD_ID, cmd_id, 0);
  }
  #[inline]
  pub fn add_sync(&mut self, sync: bool) {
    self.fbb_.push_slot::<bool>(Base::VT_SYNC, sync, false);
  }
  #[inline]
  pub fn add_error_kind(&mut self, error_kind: ErrorKind) {
    self.fbb_.push_slot::<ErrorKind>(
      Base::VT_ERROR_KIND,
      error_kind,
      ErrorKind::NoError,
    );
  }
  #[inline]
  pub fn add_error(&mut self, error: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(Base::VT_ERROR, error);
  }
  #[inline]
  pub fn add_inner_type(&mut self, inner_type: Any) {
    self
      .fbb_
      .push_slot::<Any>(Base::VT_INNER_TYPE, inner_type, Any::NONE);
  }
  #[inline]
  pub fn add_inner(
    &mut self,
    inner: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
  ) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(Base::VT_INNER, inner);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> BaseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BaseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Base<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum StartOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Start<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Start<'a> {
  type Inner = Start<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Start<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Start { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args StartArgs,
  ) -> flatbuffers::WIPOffset<Start<'bldr>> {
    let mut builder = StartBuilder::new(_fbb);
    builder.add_unused(args.unused);
    builder.finish()
  }

  pub const VT_UNUSED: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn unused(&self) -> i8 {
    self._tab.get::<i8>(Start::VT_UNUSED, Some(0)).unwrap()
  }
}

pub struct StartArgs {
  pub unused: i8,
}
impl<'a> Default for StartArgs {
  #[inline]
  fn default() -> Self {
    StartArgs { unused: 0 }
  }
}
pub struct StartBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StartBuilder<'a, 'b> {
  #[inline]
  pub fn add_unused(&mut self, unused: i8) {
    self.fbb_.push_slot::<i8>(Start::VT_UNUSED, unused, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> StartBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StartBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Start<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum StartResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StartRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StartRes<'a> {
  type Inner = StartRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> StartRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StartRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args StartResArgs<'args>,
  ) -> flatbuffers::WIPOffset<StartRes<'bldr>> {
    let mut builder = StartResBuilder::new(_fbb);
    if let Some(x) = args.xeval_delim {
      builder.add_xeval_delim(x);
    }
    if let Some(x) = args.v8_version {
      builder.add_v8_version(x);
    }
    if let Some(x) = args.deno_version {
      builder.add_deno_version(x);
    }
    if let Some(x) = args.main_module {
      builder.add_main_module(x);
    }
    if let Some(x) = args.argv {
      builder.add_argv(x);
    }
    builder.add_pid(args.pid);
    if let Some(x) = args.cwd {
      builder.add_cwd(x);
    }
    builder.add_no_color(args.no_color);
    builder.add_version_flag(args.version_flag);
    builder.add_types_flag(args.types_flag);
    builder.add_deps_flag(args.deps_flag);
    builder.add_debug_flag(args.debug_flag);
    builder.finish()
  }

  pub const VT_CWD: flatbuffers::VOffsetT = 4;
  pub const VT_PID: flatbuffers::VOffsetT = 6;
  pub const VT_ARGV: flatbuffers::VOffsetT = 8;
  pub const VT_MAIN_MODULE: flatbuffers::VOffsetT = 10;
  pub const VT_DEBUG_FLAG: flatbuffers::VOffsetT = 12;
  pub const VT_DEPS_FLAG: flatbuffers::VOffsetT = 14;
  pub const VT_TYPES_FLAG: flatbuffers::VOffsetT = 16;
  pub const VT_VERSION_FLAG: flatbuffers::VOffsetT = 18;
  pub const VT_DENO_VERSION: flatbuffers::VOffsetT = 20;
  pub const VT_V8_VERSION: flatbuffers::VOffsetT = 22;
  pub const VT_NO_COLOR: flatbuffers::VOffsetT = 24;
  pub const VT_XEVAL_DELIM: flatbuffers::VOffsetT = 26;

  #[inline]
  pub fn cwd(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(StartRes::VT_CWD, None)
  }
  #[inline]
  pub fn pid(&self) -> u32 {
    self._tab.get::<u32>(StartRes::VT_PID, Some(0)).unwrap()
  }
  #[inline]
  pub fn argv(
    &self,
  ) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<
      flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>,
    >>(StartRes::VT_ARGV, None)
  }
  #[inline]
  pub fn main_module(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(StartRes::VT_MAIN_MODULE, None)
  }
  #[inline]
  pub fn debug_flag(&self) -> bool {
    self
      ._tab
      .get::<bool>(StartRes::VT_DEBUG_FLAG, Some(false))
      .unwrap()
  }
  #[inline]
  pub fn deps_flag(&self) -> bool {
    self
      ._tab
      .get::<bool>(StartRes::VT_DEPS_FLAG, Some(false))
      .unwrap()
  }
  #[inline]
  pub fn types_flag(&self) -> bool {
    self
      ._tab
      .get::<bool>(StartRes::VT_TYPES_FLAG, Some(false))
      .unwrap()
  }
  #[inline]
  pub fn version_flag(&self) -> bool {
    self
      ._tab
      .get::<bool>(StartRes::VT_VERSION_FLAG, Some(false))
      .unwrap()
  }
  #[inline]
  pub fn deno_version(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
      StartRes::VT_DENO_VERSION,
      None,
    )
  }
  #[inline]
  pub fn v8_version(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(StartRes::VT_V8_VERSION, None)
  }
  #[inline]
  pub fn no_color(&self) -> bool {
    self
      ._tab
      .get::<bool>(StartRes::VT_NO_COLOR, Some(false))
      .unwrap()
  }
  #[inline]
  pub fn xeval_delim(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(StartRes::VT_XEVAL_DELIM, None)
  }
}

pub struct StartResArgs<'a> {
  pub cwd: Option<flatbuffers::WIPOffset<&'a str>>,
  pub pid: u32,
  pub argv: Option<
    flatbuffers::WIPOffset<
      flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
    >,
  >,
  pub main_module: Option<flatbuffers::WIPOffset<&'a str>>,
  pub debug_flag: bool,
  pub deps_flag: bool,
  pub types_flag: bool,
  pub version_flag: bool,
  pub deno_version: Option<flatbuffers::WIPOffset<&'a str>>,
  pub v8_version: Option<flatbuffers::WIPOffset<&'a str>>,
  pub no_color: bool,
  pub xeval_delim: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for StartResArgs<'a> {
  #[inline]
  fn default() -> Self {
    StartResArgs {
      cwd: None,
      pid: 0,
      argv: None,
      main_module: None,
      debug_flag: false,
      deps_flag: false,
      types_flag: false,
      version_flag: false,
      deno_version: None,
      v8_version: None,
      no_color: false,
      xeval_delim: None,
    }
  }
}
pub struct StartResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StartResBuilder<'a, 'b> {
  #[inline]
  pub fn add_cwd(&mut self, cwd: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(StartRes::VT_CWD, cwd);
  }
  #[inline]
  pub fn add_pid(&mut self, pid: u32) {
    self.fbb_.push_slot::<u32>(StartRes::VT_PID, pid, 0);
  }
  #[inline]
  pub fn add_argv(
    &mut self,
    argv: flatbuffers::WIPOffset<
      flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
    >,
  ) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(StartRes::VT_ARGV, argv);
  }
  #[inline]
  pub fn add_main_module(
    &mut self,
    main_module: flatbuffers::WIPOffset<&'b str>,
  ) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      StartRes::VT_MAIN_MODULE,
      main_module,
    );
  }
  #[inline]
  pub fn add_debug_flag(&mut self, debug_flag: bool) {
    self
      .fbb_
      .push_slot::<bool>(StartRes::VT_DEBUG_FLAG, debug_flag, false);
  }
  #[inline]
  pub fn add_deps_flag(&mut self, deps_flag: bool) {
    self
      .fbb_
      .push_slot::<bool>(StartRes::VT_DEPS_FLAG, deps_flag, false);
  }
  #[inline]
  pub fn add_types_flag(&mut self, types_flag: bool) {
    self
      .fbb_
      .push_slot::<bool>(StartRes::VT_TYPES_FLAG, types_flag, false);
  }
  #[inline]
  pub fn add_version_flag(&mut self, version_flag: bool) {
    self
      .fbb_
      .push_slot::<bool>(StartRes::VT_VERSION_FLAG, version_flag, false);
  }
  #[inline]
  pub fn add_deno_version(
    &mut self,
    deno_version: flatbuffers::WIPOffset<&'b str>,
  ) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      StartRes::VT_DENO_VERSION,
      deno_version,
    );
  }
  #[inline]
  pub fn add_v8_version(
    &mut self,
    v8_version: flatbuffers::WIPOffset<&'b str>,
  ) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      StartRes::VT_V8_VERSION,
      v8_version,
    );
  }
  #[inline]
  pub fn add_no_color(&mut self, no_color: bool) {
    self
      .fbb_
      .push_slot::<bool>(StartRes::VT_NO_COLOR, no_color, false);
  }
  #[inline]
  pub fn add_xeval_delim(
    &mut self,
    xeval_delim: flatbuffers::WIPOffset<&'b str>,
  ) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      StartRes::VT_XEVAL_DELIM,
      xeval_delim,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> StartResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StartResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StartRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FormatErrorOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FormatError<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FormatError<'a> {
  type Inner = FormatError<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> FormatError<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FormatError { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FormatErrorArgs<'args>,
  ) -> flatbuffers::WIPOffset<FormatError<'bldr>> {
    let mut builder = FormatErrorBuilder::new(_fbb);
    if let Some(x) = args.error {
      builder.add_error(x);
    }
    builder.finish()
  }

  pub const VT_ERROR: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn error(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(FormatError::VT_ERROR, None)
  }
}

pub struct FormatErrorArgs<'a> {
  pub error: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for FormatErrorArgs<'a> {
  #[inline]
  fn default() -> Self {
    FormatErrorArgs { error: None }
  }
}
pub struct FormatErrorBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FormatErrorBuilder<'a, 'b> {
  #[inline]
  pub fn add_error(&mut self, error: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      FormatError::VT_ERROR,
      error,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> FormatErrorBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FormatErrorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FormatError<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FormatErrorResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FormatErrorRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FormatErrorRes<'a> {
  type Inner = FormatErrorRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> FormatErrorRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FormatErrorRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FormatErrorResArgs<'args>,
  ) -> flatbuffers::WIPOffset<FormatErrorRes<'bldr>> {
    let mut builder = FormatErrorResBuilder::new(_fbb);
    if let Some(x) = args.error {
      builder.add_error(x);
    }
    builder.finish()
  }

  pub const VT_ERROR: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn error(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(FormatErrorRes::VT_ERROR, None)
  }
}

pub struct FormatErrorResArgs<'a> {
  pub error: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for FormatErrorResArgs<'a> {
  #[inline]
  fn default() -> Self {
    FormatErrorResArgs { error: None }
  }
}
pub struct FormatErrorResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FormatErrorResBuilder<'a, 'b> {
  #[inline]
  pub fn add_error(&mut self, error: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      FormatErrorRes::VT_ERROR,
      error,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> FormatErrorResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FormatErrorResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FormatErrorRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum CreateWorkerOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CreateWorker<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CreateWorker<'a> {
  type Inner = CreateWorker<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> CreateWorker<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CreateWorker { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CreateWorkerArgs<'args>,
  ) -> flatbuffers::WIPOffset<CreateWorker<'bldr>> {
    let mut builder = CreateWorkerBuilder::new(_fbb);
    if let Some(x) = args.source_code {
      builder.add_source_code(x);
    }
    if let Some(x) = args.specifier {
      builder.add_specifier(x);
    }
    builder.add_has_source_code(args.has_source_code);
    builder.add_include_deno_namespace(args.include_deno_namespace);
    builder.finish()
  }

  pub const VT_SPECIFIER: flatbuffers::VOffsetT = 4;
  pub const VT_INCLUDE_DENO_NAMESPACE: flatbuffers::VOffsetT = 6;
  pub const VT_HAS_SOURCE_CODE: flatbuffers::VOffsetT = 8;
  pub const VT_SOURCE_CODE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn specifier(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
      CreateWorker::VT_SPECIFIER,
      None,
    )
  }
  #[inline]
  pub fn include_deno_namespace(&self) -> bool {
    self
      ._tab
      .get::<bool>(CreateWorker::VT_INCLUDE_DENO_NAMESPACE, Some(false))
      .unwrap()
  }
  #[inline]
  pub fn has_source_code(&self) -> bool {
    self
      ._tab
      .get::<bool>(CreateWorker::VT_HAS_SOURCE_CODE, Some(false))
      .unwrap()
  }
  #[inline]
  pub fn source_code(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
      CreateWorker::VT_SOURCE_CODE,
      None,
    )
  }
}

pub struct CreateWorkerArgs<'a> {
  pub specifier: Option<flatbuffers::WIPOffset<&'a str>>,
  pub include_deno_namespace: bool,
  pub has_source_code: bool,
  pub source_code: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CreateWorkerArgs<'a> {
  #[inline]
  fn default() -> Self {
    CreateWorkerArgs {
      specifier: None,
      include_deno_namespace: false,
      has_source_code: false,
      source_code: None,
    }
  }
}
pub struct CreateWorkerBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CreateWorkerBuilder<'a, 'b> {
  #[inline]
  pub fn add_specifier(&mut self, specifier: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      CreateWorker::VT_SPECIFIER,
      specifier,
    );
  }
  #[inline]
  pub fn add_include_deno_namespace(&mut self, include_deno_namespace: bool) {
    self.fbb_.push_slot::<bool>(
      CreateWorker::VT_INCLUDE_DENO_NAMESPACE,
      include_deno_namespace,
      false,
    );
  }
  #[inline]
  pub fn add_has_source_code(&mut self, has_source_code: bool) {
    self.fbb_.push_slot::<bool>(
      CreateWorker::VT_HAS_SOURCE_CODE,
      has_source_code,
      false,
    );
  }
  #[inline]
  pub fn add_source_code(
    &mut self,
    source_code: flatbuffers::WIPOffset<&'b str>,
  ) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      CreateWorker::VT_SOURCE_CODE,
      source_code,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> CreateWorkerBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CreateWorkerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CreateWorker<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum CreateWorkerResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CreateWorkerRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CreateWorkerRes<'a> {
  type Inner = CreateWorkerRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> CreateWorkerRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CreateWorkerRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CreateWorkerResArgs,
  ) -> flatbuffers::WIPOffset<CreateWorkerRes<'bldr>> {
    let mut builder = CreateWorkerResBuilder::new(_fbb);
    builder.add_rid(args.rid);
    builder.finish()
  }

  pub const VT_RID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn rid(&self) -> u32 {
    self
      ._tab
      .get::<u32>(CreateWorkerRes::VT_RID, Some(0))
      .unwrap()
  }
}

pub struct CreateWorkerResArgs {
  pub rid: u32,
}
impl<'a> Default for CreateWorkerResArgs {
  #[inline]
  fn default() -> Self {
    CreateWorkerResArgs { rid: 0 }
  }
}
pub struct CreateWorkerResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CreateWorkerResBuilder<'a, 'b> {
  #[inline]
  pub fn add_rid(&mut self, rid: u32) {
    self.fbb_.push_slot::<u32>(CreateWorkerRes::VT_RID, rid, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> CreateWorkerResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CreateWorkerResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CreateWorkerRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum HostGetWorkerClosedOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct HostGetWorkerClosed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HostGetWorkerClosed<'a> {
  type Inner = HostGetWorkerClosed<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> HostGetWorkerClosed<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HostGetWorkerClosed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args HostGetWorkerClosedArgs,
  ) -> flatbuffers::WIPOffset<HostGetWorkerClosed<'bldr>> {
    let mut builder = HostGetWorkerClosedBuilder::new(_fbb);
    builder.add_rid(args.rid);
    builder.finish()
  }

  pub const VT_RID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn rid(&self) -> u32 {
    self
      ._tab
      .get::<u32>(HostGetWorkerClosed::VT_RID, Some(0))
      .unwrap()
  }
}

pub struct HostGetWorkerClosedArgs {
  pub rid: u32,
}
impl<'a> Default for HostGetWorkerClosedArgs {
  #[inline]
  fn default() -> Self {
    HostGetWorkerClosedArgs { rid: 0 }
  }
}
pub struct HostGetWorkerClosedBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HostGetWorkerClosedBuilder<'a, 'b> {
  #[inline]
  pub fn add_rid(&mut self, rid: u32) {
    self
      .fbb_
      .push_slot::<u32>(HostGetWorkerClosed::VT_RID, rid, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> HostGetWorkerClosedBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HostGetWorkerClosedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HostGetWorkerClosed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum HostGetMessageOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct HostGetMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HostGetMessage<'a> {
  type Inner = HostGetMessage<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> HostGetMessage<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HostGetMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args HostGetMessageArgs,
  ) -> flatbuffers::WIPOffset<HostGetMessage<'bldr>> {
    let mut builder = HostGetMessageBuilder::new(_fbb);
    builder.add_rid(args.rid);
    builder.finish()
  }

  pub const VT_RID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn rid(&self) -> u32 {
    self
      ._tab
      .get::<u32>(HostGetMessage::VT_RID, Some(0))
      .unwrap()
  }
}

pub struct HostGetMessageArgs {
  pub rid: u32,
}
impl<'a> Default for HostGetMessageArgs {
  #[inline]
  fn default() -> Self {
    HostGetMessageArgs { rid: 0 }
  }
}
pub struct HostGetMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HostGetMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_rid(&mut self, rid: u32) {
    self.fbb_.push_slot::<u32>(HostGetMessage::VT_RID, rid, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> HostGetMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HostGetMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HostGetMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum HostGetMessageResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct HostGetMessageRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HostGetMessageRes<'a> {
  type Inner = HostGetMessageRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> HostGetMessageRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HostGetMessageRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args HostGetMessageResArgs<'args>,
  ) -> flatbuffers::WIPOffset<HostGetMessageRes<'bldr>> {
    let mut builder = HostGetMessageResBuilder::new(_fbb);
    if let Some(x) = args.data {
      builder.add_data(x);
    }
    builder.finish()
  }

  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn data(&self) -> Option<&'a [u8]> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
        HostGetMessageRes::VT_DATA,
        None,
      )
      .map(|v| v.safe_slice())
  }
}

pub struct HostGetMessageResArgs<'a> {
  pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for HostGetMessageResArgs<'a> {
  #[inline]
  fn default() -> Self {
    HostGetMessageResArgs { data: None }
  }
}
pub struct HostGetMessageResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HostGetMessageResBuilder<'a, 'b> {
  #[inline]
  pub fn add_data(
    &mut self,
    data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
  ) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      HostGetMessageRes::VT_DATA,
      data,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> HostGetMessageResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HostGetMessageResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HostGetMessageRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum HostPostMessageOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct HostPostMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HostPostMessage<'a> {
  type Inner = HostPostMessage<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> HostPostMessage<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HostPostMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args HostPostMessageArgs,
  ) -> flatbuffers::WIPOffset<HostPostMessage<'bldr>> {
    let mut builder = HostPostMessageBuilder::new(_fbb);
    builder.add_rid(args.rid);
    builder.finish()
  }

  pub const VT_RID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn rid(&self) -> u32 {
    self
      ._tab
      .get::<u32>(HostPostMessage::VT_RID, Some(0))
      .unwrap()
  }
}

pub struct HostPostMessageArgs {
  pub rid: u32,
}
impl<'a> Default for HostPostMessageArgs {
  #[inline]
  fn default() -> Self {
    HostPostMessageArgs { rid: 0 }
  }
}
pub struct HostPostMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HostPostMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_rid(&mut self, rid: u32) {
    self.fbb_.push_slot::<u32>(HostPostMessage::VT_RID, rid, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> HostPostMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HostPostMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HostPostMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum WorkerGetMessageOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct WorkerGetMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WorkerGetMessage<'a> {
  type Inner = WorkerGetMessage<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> WorkerGetMessage<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WorkerGetMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args WorkerGetMessageArgs,
  ) -> flatbuffers::WIPOffset<WorkerGetMessage<'bldr>> {
    let mut builder = WorkerGetMessageBuilder::new(_fbb);
    builder.add_unused(args.unused);
    builder.finish()
  }

  pub const VT_UNUSED: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn unused(&self) -> i8 {
    self
      ._tab
      .get::<i8>(WorkerGetMessage::VT_UNUSED, Some(0))
      .unwrap()
  }
}

pub struct WorkerGetMessageArgs {
  pub unused: i8,
}
impl<'a> Default for WorkerGetMessageArgs {
  #[inline]
  fn default() -> Self {
    WorkerGetMessageArgs { unused: 0 }
  }
}
pub struct WorkerGetMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WorkerGetMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_unused(&mut self, unused: i8) {
    self
      .fbb_
      .push_slot::<i8>(WorkerGetMessage::VT_UNUSED, unused, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> WorkerGetMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WorkerGetMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WorkerGetMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum WorkerGetMessageResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct WorkerGetMessageRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WorkerGetMessageRes<'a> {
  type Inner = WorkerGetMessageRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> WorkerGetMessageRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WorkerGetMessageRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args WorkerGetMessageResArgs<'args>,
  ) -> flatbuffers::WIPOffset<WorkerGetMessageRes<'bldr>> {
    let mut builder = WorkerGetMessageResBuilder::new(_fbb);
    if let Some(x) = args.data {
      builder.add_data(x);
    }
    builder.finish()
  }

  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn data(&self) -> Option<&'a [u8]> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
        WorkerGetMessageRes::VT_DATA,
        None,
      )
      .map(|v| v.safe_slice())
  }
}

pub struct WorkerGetMessageResArgs<'a> {
  pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for WorkerGetMessageResArgs<'a> {
  #[inline]
  fn default() -> Self {
    WorkerGetMessageResArgs { data: None }
  }
}
pub struct WorkerGetMessageResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WorkerGetMessageResBuilder<'a, 'b> {
  #[inline]
  pub fn add_data(
    &mut self,
    data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
  ) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      WorkerGetMessageRes::VT_DATA,
      data,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> WorkerGetMessageResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WorkerGetMessageResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WorkerGetMessageRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum WorkerPostMessageOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct WorkerPostMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WorkerPostMessage<'a> {
  type Inner = WorkerPostMessage<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> WorkerPostMessage<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WorkerPostMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args WorkerPostMessageArgs,
  ) -> flatbuffers::WIPOffset<WorkerPostMessage<'bldr>> {
    let mut builder = WorkerPostMessageBuilder::new(_fbb);
    builder.finish()
  }
}

pub struct WorkerPostMessageArgs {}
impl<'a> Default for WorkerPostMessageArgs {
  #[inline]
  fn default() -> Self {
    WorkerPostMessageArgs {}
  }
}
pub struct WorkerPostMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WorkerPostMessageBuilder<'a, 'b> {
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> WorkerPostMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WorkerPostMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WorkerPostMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FetchSourceFileOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FetchSourceFile<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FetchSourceFile<'a> {
  type Inner = FetchSourceFile<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> FetchSourceFile<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FetchSourceFile { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FetchSourceFileArgs<'args>,
  ) -> flatbuffers::WIPOffset<FetchSourceFile<'bldr>> {
    let mut builder = FetchSourceFileBuilder::new(_fbb);
    if let Some(x) = args.referrer {
      builder.add_referrer(x);
    }
    if let Some(x) = args.specifier {
      builder.add_specifier(x);
    }
    builder.finish()
  }

  pub const VT_SPECIFIER: flatbuffers::VOffsetT = 4;
  pub const VT_REFERRER: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn specifier(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
      FetchSourceFile::VT_SPECIFIER,
      None,
    )
  }
  #[inline]
  pub fn referrer(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
      FetchSourceFile::VT_REFERRER,
      None,
    )
  }
}

pub struct FetchSourceFileArgs<'a> {
  pub specifier: Option<flatbuffers::WIPOffset<&'a str>>,
  pub referrer: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for FetchSourceFileArgs<'a> {
  #[inline]
  fn default() -> Self {
    FetchSourceFileArgs {
      specifier: None,
      referrer: None,
    }
  }
}
pub struct FetchSourceFileBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FetchSourceFileBuilder<'a, 'b> {
  #[inline]
  pub fn add_specifier(&mut self, specifier: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      FetchSourceFile::VT_SPECIFIER,
      specifier,
    );
  }
  #[inline]
  pub fn add_referrer(&mut self, referrer: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      FetchSourceFile::VT_REFERRER,
      referrer,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> FetchSourceFileBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FetchSourceFileBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FetchSourceFile<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FetchSourceFileResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FetchSourceFileRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FetchSourceFileRes<'a> {
  type Inner = FetchSourceFileRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> FetchSourceFileRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FetchSourceFileRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FetchSourceFileResArgs<'args>,
  ) -> flatbuffers::WIPOffset<FetchSourceFileRes<'bldr>> {
    let mut builder = FetchSourceFileResBuilder::new(_fbb);
    if let Some(x) = args.data {
      builder.add_data(x);
    }
    if let Some(x) = args.filename {
      builder.add_filename(x);
    }
    if let Some(x) = args.module_name {
      builder.add_module_name(x);
    }
    builder.add_media_type(args.media_type);
    builder.finish()
  }

  pub const VT_MODULE_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_FILENAME: flatbuffers::VOffsetT = 6;
  pub const VT_MEDIA_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_DATA: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn module_name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
      FetchSourceFileRes::VT_MODULE_NAME,
      None,
    )
  }
  #[inline]
  pub fn filename(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
      FetchSourceFileRes::VT_FILENAME,
      None,
    )
  }
  #[inline]
  pub fn media_type(&self) -> MediaType {
    self
      ._tab
      .get::<MediaType>(
        FetchSourceFileRes::VT_MEDIA_TYPE,
        Some(MediaType::JavaScript),
      )
      .unwrap()
  }
  #[inline]
  pub fn data(&self) -> Option<&'a [u8]> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
        FetchSourceFileRes::VT_DATA,
        None,
      )
      .map(|v| v.safe_slice())
  }
}

pub struct FetchSourceFileResArgs<'a> {
  pub module_name: Option<flatbuffers::WIPOffset<&'a str>>,
  pub filename: Option<flatbuffers::WIPOffset<&'a str>>,
  pub media_type: MediaType,
  pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for FetchSourceFileResArgs<'a> {
  #[inline]
  fn default() -> Self {
    FetchSourceFileResArgs {
      module_name: None,
      filename: None,
      media_type: MediaType::JavaScript,
      data: None,
    }
  }
}
pub struct FetchSourceFileResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FetchSourceFileResBuilder<'a, 'b> {
  #[inline]
  pub fn add_module_name(
    &mut self,
    module_name: flatbuffers::WIPOffset<&'b str>,
  ) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      FetchSourceFileRes::VT_MODULE_NAME,
      module_name,
    );
  }
  #[inline]
  pub fn add_filename(&mut self, filename: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      FetchSourceFileRes::VT_FILENAME,
      filename,
    );
  }
  #[inline]
  pub fn add_media_type(&mut self, media_type: MediaType) {
    self.fbb_.push_slot::<MediaType>(
      FetchSourceFileRes::VT_MEDIA_TYPE,
      media_type,
      MediaType::JavaScript,
    );
  }
  #[inline]
  pub fn add_data(
    &mut self,
    data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
  ) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      FetchSourceFileRes::VT_DATA,
      data,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> FetchSourceFileResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FetchSourceFileResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FetchSourceFileRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ApplySourceMapOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ApplySourceMap<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ApplySourceMap<'a> {
  type Inner = ApplySourceMap<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> ApplySourceMap<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ApplySourceMap { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ApplySourceMapArgs<'args>,
  ) -> flatbuffers::WIPOffset<ApplySourceMap<'bldr>> {
    let mut builder = ApplySourceMapBuilder::new(_fbb);
    builder.add_column(args.column);
    builder.add_line(args.line);
    if let Some(x) = args.filename {
      builder.add_filename(x);
    }
    builder.finish()
  }

  pub const VT_FILENAME: flatbuffers::VOffsetT = 4;
  pub const VT_LINE: flatbuffers::VOffsetT = 6;
  pub const VT_COLUMN: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn filename(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
      ApplySourceMap::VT_FILENAME,
      None,
    )
  }
  #[inline]
  pub fn line(&self) -> i32 {
    self
      ._tab
      .get::<i32>(ApplySourceMap::VT_LINE, Some(0))
      .unwrap()
  }
  #[inline]
  pub fn column(&self) -> i32 {
    self
      ._tab
      .get::<i32>(ApplySourceMap::VT_COLUMN, Some(0))
      .unwrap()
  }
}

pub struct ApplySourceMapArgs<'a> {
  pub filename: Option<flatbuffers::WIPOffset<&'a str>>,
  pub line: i32,
  pub column: i32,
}
impl<'a> Default for ApplySourceMapArgs<'a> {
  #[inline]
  fn default() -> Self {
    ApplySourceMapArgs {
      filename: None,
      line: 0,
      column: 0,
    }
  }
}
pub struct ApplySourceMapBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ApplySourceMapBuilder<'a, 'b> {
  #[inline]
  pub fn add_filename(&mut self, filename: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      ApplySourceMap::VT_FILENAME,
      filename,
    );
  }
  #[inline]
  pub fn add_line(&mut self, line: i32) {
    self.fbb_.push_slot::<i32>(ApplySourceMap::VT_LINE, line, 0);
  }
  #[inline]
  pub fn add_column(&mut self, column: i32) {
    self
      .fbb_
      .push_slot::<i32>(ApplySourceMap::VT_COLUMN, column, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> ApplySourceMapBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ApplySourceMapBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ApplySourceMap<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum CacheOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Cache<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Cache<'a> {
  type Inner = Cache<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Cache<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Cache { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CacheArgs<'args>,
  ) -> flatbuffers::WIPOffset<Cache<'bldr>> {
    let mut builder = CacheBuilder::new(_fbb);
    if let Some(x) = args.contents {
      builder.add_contents(x);
    }
    if let Some(x) = args.module_id {
      builder.add_module_id(x);
    }
    if let Some(x) = args.extension {
      builder.add_extension(x);
    }
    builder.finish()
  }

  pub const VT_EXTENSION: flatbuffers::VOffsetT = 4;
  pub const VT_MODULE_ID: flatbuffers::VOffsetT = 6;
  pub const VT_CONTENTS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn extension(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Cache::VT_EXTENSION, None)
  }
  #[inline]
  pub fn module_id(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Cache::VT_MODULE_ID, None)
  }
  #[inline]
  pub fn contents(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Cache::VT_CONTENTS, None)
  }
}

pub struct CacheArgs<'a> {
  pub extension: Option<flatbuffers::WIPOffset<&'a str>>,
  pub module_id: Option<flatbuffers::WIPOffset<&'a str>>,
  pub contents: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CacheArgs<'a> {
  #[inline]
  fn default() -> Self {
    CacheArgs {
      extension: None,
      module_id: None,
      contents: None,
    }
  }
}
pub struct CacheBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CacheBuilder<'a, 'b> {
  #[inline]
  pub fn add_extension(&mut self, extension: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      Cache::VT_EXTENSION,
      extension,
    );
  }
  #[inline]
  pub fn add_module_id(&mut self, module_id: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      Cache::VT_MODULE_ID,
      module_id,
    );
  }
  #[inline]
  pub fn add_contents(&mut self, contents: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      Cache::VT_CONTENTS,
      contents,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> CacheBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CacheBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Cache<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ChdirOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Chdir<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Chdir<'a> {
  type Inner = Chdir<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Chdir<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Chdir { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ChdirArgs<'args>,
  ) -> flatbuffers::WIPOffset<Chdir<'bldr>> {
    let mut builder = ChdirBuilder::new(_fbb);
    if let Some(x) = args.directory {
      builder.add_directory(x);
    }
    builder.finish()
  }

  pub const VT_DIRECTORY: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn directory(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Chdir::VT_DIRECTORY, None)
  }
}

pub struct ChdirArgs<'a> {
  pub directory: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ChdirArgs<'a> {
  #[inline]
  fn default() -> Self {
    ChdirArgs { directory: None }
  }
}
pub struct ChdirBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ChdirBuilder<'a, 'b> {
  #[inline]
  pub fn add_directory(&mut self, directory: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      Chdir::VT_DIRECTORY,
      directory,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> ChdirBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ChdirBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Chdir<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GlobalTimerOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GlobalTimer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GlobalTimer<'a> {
  type Inner = GlobalTimer<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> GlobalTimer<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GlobalTimer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GlobalTimerArgs,
  ) -> flatbuffers::WIPOffset<GlobalTimer<'bldr>> {
    let mut builder = GlobalTimerBuilder::new(_fbb);
    builder.add_timeout(args.timeout);
    builder.finish()
  }

  pub const VT_TIMEOUT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn timeout(&self) -> i32 {
    self
      ._tab
      .get::<i32>(GlobalTimer::VT_TIMEOUT, Some(0))
      .unwrap()
  }
}

pub struct GlobalTimerArgs {
  pub timeout: i32,
}
impl<'a> Default for GlobalTimerArgs {
  #[inline]
  fn default() -> Self {
    GlobalTimerArgs { timeout: 0 }
  }
}
pub struct GlobalTimerBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GlobalTimerBuilder<'a, 'b> {
  #[inline]
  pub fn add_timeout(&mut self, timeout: i32) {
    self
      .fbb_
      .push_slot::<i32>(GlobalTimer::VT_TIMEOUT, timeout, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> GlobalTimerBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GlobalTimerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GlobalTimer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GlobalTimerResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GlobalTimerRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GlobalTimerRes<'a> {
  type Inner = GlobalTimerRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> GlobalTimerRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GlobalTimerRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args GlobalTimerResArgs,
  ) -> flatbuffers::WIPOffset<GlobalTimerRes<'bldr>> {
    let mut builder = GlobalTimerResBuilder::new(_fbb);
    builder.finish()
  }
}

pub struct GlobalTimerResArgs {}
impl<'a> Default for GlobalTimerResArgs {
  #[inline]
  fn default() -> Self {
    GlobalTimerResArgs {}
  }
}
pub struct GlobalTimerResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GlobalTimerResBuilder<'a, 'b> {
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> GlobalTimerResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GlobalTimerResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GlobalTimerRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GlobalTimerStopOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GlobalTimerStop<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GlobalTimerStop<'a> {
  type Inner = GlobalTimerStop<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> GlobalTimerStop<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GlobalTimerStop { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args GlobalTimerStopArgs,
  ) -> flatbuffers::WIPOffset<GlobalTimerStop<'bldr>> {
    let mut builder = GlobalTimerStopBuilder::new(_fbb);
    builder.finish()
  }
}

pub struct GlobalTimerStopArgs {}
impl<'a> Default for GlobalTimerStopArgs {
  #[inline]
  fn default() -> Self {
    GlobalTimerStopArgs {}
  }
}
pub struct GlobalTimerStopBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GlobalTimerStopBuilder<'a, 'b> {
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> GlobalTimerStopBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GlobalTimerStopBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GlobalTimerStop<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ExitOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Exit<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Exit<'a> {
  type Inner = Exit<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Exit<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Exit { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ExitArgs,
  ) -> flatbuffers::WIPOffset<Exit<'bldr>> {
    let mut builder = ExitBuilder::new(_fbb);
    builder.add_code(args.code);
    builder.finish()
  }

  pub const VT_CODE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn code(&self) -> i32 {
    self._tab.get::<i32>(Exit::VT_CODE, Some(0)).unwrap()
  }
}

pub struct ExitArgs {
  pub code: i32,
}
impl<'a> Default for ExitArgs {
  #[inline]
  fn default() -> Self {
    ExitArgs { code: 0 }
  }
}
pub struct ExitBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExitBuilder<'a, 'b> {
  #[inline]
  pub fn add_code(&mut self, code: i32) {
    self.fbb_.push_slot::<i32>(Exit::VT_CODE, code, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> ExitBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ExitBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Exit<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum EnvironOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Environ<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Environ<'a> {
  type Inner = Environ<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Environ<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Environ { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args EnvironArgs,
  ) -> flatbuffers::WIPOffset<Environ<'bldr>> {
    let mut builder = EnvironBuilder::new(_fbb);
    builder.finish()
  }
}

pub struct EnvironArgs {}
impl<'a> Default for EnvironArgs {
  #[inline]
  fn default() -> Self {
    EnvironArgs {}
  }
}
pub struct EnvironBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EnvironBuilder<'a, 'b> {
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> EnvironBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EnvironBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Environ<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum SetEnvOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct SetEnv<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetEnv<'a> {
  type Inner = SetEnv<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> SetEnv<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SetEnv { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SetEnvArgs<'args>,
  ) -> flatbuffers::WIPOffset<SetEnv<'bldr>> {
    let mut builder = SetEnvBuilder::new(_fbb);
    if let Some(x) = args.value {
      builder.add_value(x);
    }
    if let Some(x) = args.key {
      builder.add_key(x);
    }
    builder.finish()
  }

  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(SetEnv::VT_KEY, None)
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(SetEnv::VT_VALUE, None)
  }
}

pub struct SetEnvArgs<'a> {
  pub key: Option<flatbuffers::WIPOffset<&'a str>>,
  pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SetEnvArgs<'a> {
  #[inline]
  fn default() -> Self {
    SetEnvArgs {
      key: None,
      value: None,
    }
  }
}
pub struct SetEnvBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SetEnvBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(SetEnv::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(SetEnv::VT_VALUE, value);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> SetEnvBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SetEnvBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SetEnv<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum EnvironResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct EnvironRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EnvironRes<'a> {
  type Inner = EnvironRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> EnvironRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EnvironRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args EnvironResArgs<'args>,
  ) -> flatbuffers::WIPOffset<EnvironRes<'bldr>> {
    let mut builder = EnvironResBuilder::new(_fbb);
    if let Some(x) = args.map {
      builder.add_map(x);
    }
    builder.finish()
  }

  pub const VT_MAP: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn map(
    &self,
  ) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<KeyValue<'a>>>>
  {
    self._tab.get::<flatbuffers::ForwardsUOffset<
      flatbuffers::Vector<flatbuffers::ForwardsUOffset<KeyValue<'a>>>,
    >>(EnvironRes::VT_MAP, None)
  }
}

pub struct EnvironResArgs<'a> {
  pub map: Option<
    flatbuffers::WIPOffset<
      flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>,
    >,
  >,
}
impl<'a> Default for EnvironResArgs<'a> {
  #[inline]
  fn default() -> Self {
    EnvironResArgs { map: None }
  }
}
pub struct EnvironResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EnvironResBuilder<'a, 'b> {
  #[inline]
  pub fn add_map(
    &mut self,
    map: flatbuffers::WIPOffset<
      flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<KeyValue<'b>>>,
    >,
  ) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(EnvironRes::VT_MAP, map);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> EnvironResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EnvironResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EnvironRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum KeyValueOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct KeyValue<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KeyValue<'a> {
  type Inner = KeyValue<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> KeyValue<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KeyValue { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args KeyValueArgs<'args>,
  ) -> flatbuffers::WIPOffset<KeyValue<'bldr>> {
    let mut builder = KeyValueBuilder::new(_fbb);
    if let Some(x) = args.value {
      builder.add_value(x);
    }
    if let Some(x) = args.key {
      builder.add_key(x);
    }
    builder.finish()
  }

  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(KeyValue::VT_KEY, None)
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(KeyValue::VT_VALUE, None)
  }
}

pub struct KeyValueArgs<'a> {
  pub key: Option<flatbuffers::WIPOffset<&'a str>>,
  pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for KeyValueArgs<'a> {
  #[inline]
  fn default() -> Self {
    KeyValueArgs {
      key: None,
      value: None,
    }
  }
}
pub struct KeyValueBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> KeyValueBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(KeyValue::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(KeyValue::VT_VALUE, value);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> KeyValueBuilder<'a, 'b> {
    let start = _fbb.start_table();
    KeyValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KeyValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PermissionsOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Permissions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Permissions<'a> {
  type Inner = Permissions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Permissions<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Permissions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args PermissionsArgs,
  ) -> flatbuffers::WIPOffset<Permissions<'bldr>> {
    let mut builder = PermissionsBuilder::new(_fbb);
    builder.finish()
  }
}

pub struct PermissionsArgs {}
impl<'a> Default for PermissionsArgs {
  #[inline]
  fn default() -> Self {
    PermissionsArgs {}
  }
}
pub struct PermissionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PermissionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> PermissionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PermissionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Permissions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PermissionRevokeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct PermissionRevoke<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PermissionRevoke<'a> {
  type Inner = PermissionRevoke<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> PermissionRevoke<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PermissionRevoke { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PermissionRevokeArgs<'args>,
  ) -> flatbuffers::WIPOffset<PermissionRevoke<'bldr>> {
    let mut builder = PermissionRevokeBuilder::new(_fbb);
    if let Some(x) = args.permission {
      builder.add_permission(x);
    }
    builder.finish()
  }

  pub const VT_PERMISSION: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn permission(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
      PermissionRevoke::VT_PERMISSION,
      None,
    )
  }
}

pub struct PermissionRevokeArgs<'a> {
  pub permission: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PermissionRevokeArgs<'a> {
  #[inline]
  fn default() -> Self {
    PermissionRevokeArgs { permission: None }
  }
}
pub struct PermissionRevokeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PermissionRevokeBuilder<'a, 'b> {
  #[inline]
  pub fn add_permission(
    &mut self,
    permission: flatbuffers::WIPOffset<&'b str>,
  ) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      PermissionRevoke::VT_PERMISSION,
      permission,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> PermissionRevokeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PermissionRevokeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PermissionRevoke<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PermissionsResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct PermissionsRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PermissionsRes<'a> {
  type Inner = PermissionsRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> PermissionsRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PermissionsRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PermissionsResArgs,
  ) -> flatbuffers::WIPOffset<PermissionsRes<'bldr>> {
    let mut builder = PermissionsResBuilder::new(_fbb);
    builder.add_hrtime(args.hrtime);
    builder.add_env(args.env);
    builder.add_net(args.net);
    builder.add_write(args.write);
    builder.add_read(args.read);
    builder.add_run(args.run);
    builder.finish()
  }

  pub const VT_RUN: flatbuffers::VOffsetT = 4;
  pub const VT_READ: flatbuffers::VOffsetT = 6;
  pub const VT_WRITE: flatbuffers::VOffsetT = 8;
  pub const VT_NET: flatbuffers::VOffsetT = 10;
  pub const VT_ENV: flatbuffers::VOffsetT = 12;
  pub const VT_HRTIME: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn run(&self) -> bool {
    self
      ._tab
      .get::<bool>(PermissionsRes::VT_RUN, Some(false))
      .unwrap()
  }
  #[inline]
  pub fn read(&self) -> bool {
    self
      ._tab
      .get::<bool>(PermissionsRes::VT_READ, Some(false))
      .unwrap()
  }
  #[inline]
  pub fn write(&self) -> bool {
    self
      ._tab
      .get::<bool>(PermissionsRes::VT_WRITE, Some(false))
      .unwrap()
  }
  #[inline]
  pub fn net(&self) -> bool {
    self
      ._tab
      .get::<bool>(PermissionsRes::VT_NET, Some(false))
      .unwrap()
  }
  #[inline]
  pub fn env(&self) -> bool {
    self
      ._tab
      .get::<bool>(PermissionsRes::VT_ENV, Some(false))
      .unwrap()
  }
  #[inline]
  pub fn hrtime(&self) -> bool {
    self
      ._tab
      .get::<bool>(PermissionsRes::VT_HRTIME, Some(false))
      .unwrap()
  }
}

pub struct PermissionsResArgs {
  pub run: bool,
  pub read: bool,
  pub write: bool,
  pub net: bool,
  pub env: bool,
  pub hrtime: bool,
}
impl<'a> Default for PermissionsResArgs {
  #[inline]
  fn default() -> Self {
    PermissionsResArgs {
      run: false,
      read: false,
      write: false,
      net: false,
      env: false,
      hrtime: false,
    }
  }
}
pub struct PermissionsResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PermissionsResBuilder<'a, 'b> {
  #[inline]
  pub fn add_run(&mut self, run: bool) {
    self
      .fbb_
      .push_slot::<bool>(PermissionsRes::VT_RUN, run, false);
  }
  #[inline]
  pub fn add_read(&mut self, read: bool) {
    self
      .fbb_
      .push_slot::<bool>(PermissionsRes::VT_READ, read, false);
  }
  #[inline]
  pub fn add_write(&mut self, write: bool) {
    self
      .fbb_
      .push_slot::<bool>(PermissionsRes::VT_WRITE, write, false);
  }
  #[inline]
  pub fn add_net(&mut self, net: bool) {
    self
      .fbb_
      .push_slot::<bool>(PermissionsRes::VT_NET, net, false);
  }
  #[inline]
  pub fn add_env(&mut self, env: bool) {
    self
      .fbb_
      .push_slot::<bool>(PermissionsRes::VT_ENV, env, false);
  }
  #[inline]
  pub fn add_hrtime(&mut self, hrtime: bool) {
    self
      .fbb_
      .push_slot::<bool>(PermissionsRes::VT_HRTIME, hrtime, false);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> PermissionsResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PermissionsResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PermissionsRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum HttpHeaderOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct HttpHeader<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HttpHeader<'a> {
  type Inner = HttpHeader<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> HttpHeader<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HttpHeader { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args HttpHeaderArgs<'args>,
  ) -> flatbuffers::WIPOffset<HttpHeader<'bldr>> {
    let mut builder = HttpHeaderBuilder::new(_fbb);
    if let Some(x) = args.fields {
      builder.add_fields(x);
    }
    if let Some(x) = args.url {
      builder.add_url(x);
    }
    if let Some(x) = args.method {
      builder.add_method(x);
    }
    builder.add_status(args.status);
    builder.add_is_request(args.is_request);
    builder.finish()
  }

  pub const VT_IS_REQUEST: flatbuffers::VOffsetT = 4;
  pub const VT_METHOD: flatbuffers::VOffsetT = 6;
  pub const VT_URL: flatbuffers::VOffsetT = 8;
  pub const VT_STATUS: flatbuffers::VOffsetT = 10;
  pub const VT_FIELDS: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn is_request(&self) -> bool {
    self
      ._tab
      .get::<bool>(HttpHeader::VT_IS_REQUEST, Some(false))
      .unwrap()
  }
  #[inline]
  pub fn method(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(HttpHeader::VT_METHOD, None)
  }
  #[inline]
  pub fn url(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(HttpHeader::VT_URL, None)
  }
  #[inline]
  pub fn status(&self) -> u16 {
    self
      ._tab
      .get::<u16>(HttpHeader::VT_STATUS, Some(0))
      .unwrap()
  }
  #[inline]
  pub fn fields(
    &self,
  ) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<KeyValue<'a>>>>
  {
    self._tab.get::<flatbuffers::ForwardsUOffset<
      flatbuffers::Vector<flatbuffers::ForwardsUOffset<KeyValue<'a>>>,
    >>(HttpHeader::VT_FIELDS, None)
  }
}

pub struct HttpHeaderArgs<'a> {
  pub is_request: bool,
  pub method: Option<flatbuffers::WIPOffset<&'a str>>,
  pub url: Option<flatbuffers::WIPOffset<&'a str>>,
  pub status: u16,
  pub fields: Option<
    flatbuffers::WIPOffset<
      flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>,
    >,
  >,
}
impl<'a> Default for HttpHeaderArgs<'a> {
  #[inline]
  fn default() -> Self {
    HttpHeaderArgs {
      is_request: false,
      method: None,
      url: None,
      status: 0,
      fields: None,
    }
  }
}
pub struct HttpHeaderBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HttpHeaderBuilder<'a, 'b> {
  #[inline]
  pub fn add_is_request(&mut self, is_request: bool) {
    self
      .fbb_
      .push_slot::<bool>(HttpHeader::VT_IS_REQUEST, is_request, false);
  }
  #[inline]
  pub fn add_method(&mut self, method: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      HttpHeader::VT_METHOD,
      method,
    );
  }
  #[inline]
  pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(HttpHeader::VT_URL, url);
  }
  #[inline]
  pub fn add_status(&mut self, status: u16) {
    self.fbb_.push_slot::<u16>(HttpHeader::VT_STATUS, status, 0);
  }
  #[inline]
  pub fn add_fields(
    &mut self,
    fields: flatbuffers::WIPOffset<
      flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<KeyValue<'b>>>,
    >,
  ) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      HttpHeader::VT_FIELDS,
      fields,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> HttpHeaderBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HttpHeaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HttpHeader<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FetchOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Fetch<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Fetch<'a> {
  type Inner = Fetch<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Fetch<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Fetch { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FetchArgs<'args>,
  ) -> flatbuffers::WIPOffset<Fetch<'bldr>> {
    let mut builder = FetchBuilder::new(_fbb);
    if let Some(x) = args.header {
      builder.add_header(x);
    }
    builder.finish()
  }

  pub const VT_HEADER: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn header(&self) -> Option<HttpHeader<'a>> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<HttpHeader<'a>>>(
        Fetch::VT_HEADER,
        None,
      )
  }
}

pub struct FetchArgs<'a> {
  pub header: Option<flatbuffers::WIPOffset<HttpHeader<'a>>>,
}
impl<'a> Default for FetchArgs<'a> {
  #[inline]
  fn default() -> Self {
    FetchArgs { header: None }
  }
}
pub struct FetchBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FetchBuilder<'a, 'b> {
  #[inline]
  pub fn add_header(&mut self, header: flatbuffers::WIPOffset<HttpHeader<'b>>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<HttpHeader>>(
        Fetch::VT_HEADER,
        header,
      );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> FetchBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FetchBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Fetch<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FetchResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FetchRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FetchRes<'a> {
  type Inner = FetchRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> FetchRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FetchRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FetchResArgs<'args>,
  ) -> flatbuffers::WIPOffset<FetchRes<'bldr>> {
    let mut builder = FetchResBuilder::new(_fbb);
    builder.add_body_rid(args.body_rid);
    if let Some(x) = args.header {
      builder.add_header(x);
    }
    builder.finish()
  }

  pub const VT_HEADER: flatbuffers::VOffsetT = 4;
  pub const VT_BODY_RID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn header(&self) -> Option<HttpHeader<'a>> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<HttpHeader<'a>>>(
        FetchRes::VT_HEADER,
        None,
      )
  }
  #[inline]
  pub fn body_rid(&self) -> u32 {
    self
      ._tab
      .get::<u32>(FetchRes::VT_BODY_RID, Some(0))
      .unwrap()
  }
}

pub struct FetchResArgs<'a> {
  pub header: Option<flatbuffers::WIPOffset<HttpHeader<'a>>>,
  pub body_rid: u32,
}
impl<'a> Default for FetchResArgs<'a> {
  #[inline]
  fn default() -> Self {
    FetchResArgs {
      header: None,
      body_rid: 0,
    }
  }
}
pub struct FetchResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FetchResBuilder<'a, 'b> {
  #[inline]
  pub fn add_header(&mut self, header: flatbuffers::WIPOffset<HttpHeader<'b>>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<HttpHeader>>(
        FetchRes::VT_HEADER,
        header,
      );
  }
  #[inline]
  pub fn add_body_rid(&mut self, body_rid: u32) {
    self
      .fbb_
      .push_slot::<u32>(FetchRes::VT_BODY_RID, body_rid, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> FetchResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FetchResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FetchRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum MakeTempDirOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct MakeTempDir<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MakeTempDir<'a> {
  type Inner = MakeTempDir<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> MakeTempDir<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MakeTempDir { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MakeTempDirArgs<'args>,
  ) -> flatbuffers::WIPOffset<MakeTempDir<'bldr>> {
    let mut builder = MakeTempDirBuilder::new(_fbb);
    if let Some(x) = args.suffix {
      builder.add_suffix(x);
    }
    if let Some(x) = args.prefix {
      builder.add_prefix(x);
    }
    if let Some(x) = args.dir {
      builder.add_dir(x);
    }
    builder.finish()
  }

  pub const VT_DIR: flatbuffers::VOffsetT = 4;
  pub const VT_PREFIX: flatbuffers::VOffsetT = 6;
  pub const VT_SUFFIX: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn dir(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(MakeTempDir::VT_DIR, None)
  }
  #[inline]
  pub fn prefix(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(MakeTempDir::VT_PREFIX, None)
  }
  #[inline]
  pub fn suffix(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(MakeTempDir::VT_SUFFIX, None)
  }
}

pub struct MakeTempDirArgs<'a> {
  pub dir: Option<flatbuffers::WIPOffset<&'a str>>,
  pub prefix: Option<flatbuffers::WIPOffset<&'a str>>,
  pub suffix: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for MakeTempDirArgs<'a> {
  #[inline]
  fn default() -> Self {
    MakeTempDirArgs {
      dir: None,
      prefix: None,
      suffix: None,
    }
  }
}
pub struct MakeTempDirBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MakeTempDirBuilder<'a, 'b> {
  #[inline]
  pub fn add_dir(&mut self, dir: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(MakeTempDir::VT_DIR, dir);
  }
  #[inline]
  pub fn add_prefix(&mut self, prefix: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      MakeTempDir::VT_PREFIX,
      prefix,
    );
  }
  #[inline]
  pub fn add_suffix(&mut self, suffix: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      MakeTempDir::VT_SUFFIX,
      suffix,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> MakeTempDirBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MakeTempDirBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MakeTempDir<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum MakeTempDirResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct MakeTempDirRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MakeTempDirRes<'a> {
  type Inner = MakeTempDirRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> MakeTempDirRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MakeTempDirRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MakeTempDirResArgs<'args>,
  ) -> flatbuffers::WIPOffset<MakeTempDirRes<'bldr>> {
    let mut builder = MakeTempDirResBuilder::new(_fbb);
    if let Some(x) = args.path {
      builder.add_path(x);
    }
    builder.finish()
  }

  pub const VT_PATH: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn path(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(MakeTempDirRes::VT_PATH, None)
  }
}

pub struct MakeTempDirResArgs<'a> {
  pub path: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for MakeTempDirResArgs<'a> {
  #[inline]
  fn default() -> Self {
    MakeTempDirResArgs { path: None }
  }
}
pub struct MakeTempDirResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MakeTempDirResBuilder<'a, 'b> {
  #[inline]
  pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      MakeTempDirRes::VT_PATH,
      path,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> MakeTempDirResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MakeTempDirResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MakeTempDirRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum MkdirOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Mkdir<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Mkdir<'a> {
  type Inner = Mkdir<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Mkdir<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Mkdir { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MkdirArgs<'args>,
  ) -> flatbuffers::WIPOffset<Mkdir<'bldr>> {
    let mut builder = MkdirBuilder::new(_fbb);
    builder.add_mode(args.mode);
    if let Some(x) = args.path {
      builder.add_path(x);
    }
    builder.add_recursive(args.recursive);
    builder.finish()
  }

  pub const VT_PATH: flatbuffers::VOffsetT = 4;
  pub const VT_RECURSIVE: flatbuffers::VOffsetT = 6;
  pub const VT_MODE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn path(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Mkdir::VT_PATH, None)
  }
  #[inline]
  pub fn recursive(&self) -> bool {
    self
      ._tab
      .get::<bool>(Mkdir::VT_RECURSIVE, Some(false))
      .unwrap()
  }
  #[inline]
  pub fn mode(&self) -> u32 {
    self._tab.get::<u32>(Mkdir::VT_MODE, Some(0)).unwrap()
  }
}

pub struct MkdirArgs<'a> {
  pub path: Option<flatbuffers::WIPOffset<&'a str>>,
  pub recursive: bool,
  pub mode: u32,
}
impl<'a> Default for MkdirArgs<'a> {
  #[inline]
  fn default() -> Self {
    MkdirArgs {
      path: None,
      recursive: false,
      mode: 0,
    }
  }
}
pub struct MkdirBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MkdirBuilder<'a, 'b> {
  #[inline]
  pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(Mkdir::VT_PATH, path);
  }
  #[inline]
  pub fn add_recursive(&mut self, recursive: bool) {
    self
      .fbb_
      .push_slot::<bool>(Mkdir::VT_RECURSIVE, recursive, false);
  }
  #[inline]
  pub fn add_mode(&mut self, mode: u32) {
    self.fbb_.push_slot::<u32>(Mkdir::VT_MODE, mode, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> MkdirBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MkdirBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Mkdir<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ChmodOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Chmod<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Chmod<'a> {
  type Inner = Chmod<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Chmod<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Chmod { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ChmodArgs<'args>,
  ) -> flatbuffers::WIPOffset<Chmod<'bldr>> {
    let mut builder = ChmodBuilder::new(_fbb);
    builder.add_mode(args.mode);
    if let Some(x) = args.path {
      builder.add_path(x);
    }
    builder.finish()
  }

  pub const VT_PATH: flatbuffers::VOffsetT = 4;
  pub const VT_MODE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn path(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Chmod::VT_PATH, None)
  }
  #[inline]
  pub fn mode(&self) -> u32 {
    self._tab.get::<u32>(Chmod::VT_MODE, Some(0)).unwrap()
  }
}

pub struct ChmodArgs<'a> {
  pub path: Option<flatbuffers::WIPOffset<&'a str>>,
  pub mode: u32,
}
impl<'a> Default for ChmodArgs<'a> {
  #[inline]
  fn default() -> Self {
    ChmodArgs {
      path: None,
      mode: 0,
    }
  }
}
pub struct ChmodBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ChmodBuilder<'a, 'b> {
  #[inline]
  pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(Chmod::VT_PATH, path);
  }
  #[inline]
  pub fn add_mode(&mut self, mode: u32) {
    self.fbb_.push_slot::<u32>(Chmod::VT_MODE, mode, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> ChmodBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ChmodBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Chmod<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ChownOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Chown<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Chown<'a> {
  type Inner = Chown<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Chown<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Chown { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ChownArgs<'args>,
  ) -> flatbuffers::WIPOffset<Chown<'bldr>> {
    let mut builder = ChownBuilder::new(_fbb);
    builder.add_gid(args.gid);
    builder.add_uid(args.uid);
    if let Some(x) = args.path {
      builder.add_path(x);
    }
    builder.finish()
  }

  pub const VT_PATH: flatbuffers::VOffsetT = 4;
  pub const VT_UID: flatbuffers::VOffsetT = 6;
  pub const VT_GID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn path(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Chown::VT_PATH, None)
  }
  #[inline]
  pub fn uid(&self) -> u32 {
    self._tab.get::<u32>(Chown::VT_UID, Some(0)).unwrap()
  }
  #[inline]
  pub fn gid(&self) -> u32 {
    self._tab.get::<u32>(Chown::VT_GID, Some(0)).unwrap()
  }
}

pub struct ChownArgs<'a> {
  pub path: Option<flatbuffers::WIPOffset<&'a str>>,
  pub uid: u32,
  pub gid: u32,
}
impl<'a> Default for ChownArgs<'a> {
  #[inline]
  fn default() -> Self {
    ChownArgs {
      path: None,
      uid: 0,
      gid: 0,
    }
  }
}
pub struct ChownBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ChownBuilder<'a, 'b> {
  #[inline]
  pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(Chown::VT_PATH, path);
  }
  #[inline]
  pub fn add_uid(&mut self, uid: u32) {
    self.fbb_.push_slot::<u32>(Chown::VT_UID, uid, 0);
  }
  #[inline]
  pub fn add_gid(&mut self, gid: u32) {
    self.fbb_.push_slot::<u32>(Chown::VT_GID, gid, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> ChownBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ChownBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Chown<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RemoveOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Remove<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Remove<'a> {
  type Inner = Remove<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Remove<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Remove { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RemoveArgs<'args>,
  ) -> flatbuffers::WIPOffset<Remove<'bldr>> {
    let mut builder = RemoveBuilder::new(_fbb);
    if let Some(x) = args.path {
      builder.add_path(x);
    }
    builder.add_recursive(args.recursive);
    builder.finish()
  }

  pub const VT_PATH: flatbuffers::VOffsetT = 4;
  pub const VT_RECURSIVE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn path(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Remove::VT_PATH, None)
  }
  #[inline]
  pub fn recursive(&self) -> bool {
    self
      ._tab
      .get::<bool>(Remove::VT_RECURSIVE, Some(false))
      .unwrap()
  }
}

pub struct RemoveArgs<'a> {
  pub path: Option<flatbuffers::WIPOffset<&'a str>>,
  pub recursive: bool,
}
impl<'a> Default for RemoveArgs<'a> {
  #[inline]
  fn default() -> Self {
    RemoveArgs {
      path: None,
      recursive: false,
    }
  }
}
pub struct RemoveBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RemoveBuilder<'a, 'b> {
  #[inline]
  pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(Remove::VT_PATH, path);
  }
  #[inline]
  pub fn add_recursive(&mut self, recursive: bool) {
    self
      .fbb_
      .push_slot::<bool>(Remove::VT_RECURSIVE, recursive, false);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> RemoveBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RemoveBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Remove<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ReadDirOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ReadDir<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadDir<'a> {
  type Inner = ReadDir<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> ReadDir<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReadDir { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ReadDirArgs<'args>,
  ) -> flatbuffers::WIPOffset<ReadDir<'bldr>> {
    let mut builder = ReadDirBuilder::new(_fbb);
    if let Some(x) = args.path {
      builder.add_path(x);
    }
    builder.finish()
  }

  pub const VT_PATH: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn path(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(ReadDir::VT_PATH, None)
  }
}

pub struct ReadDirArgs<'a> {
  pub path: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ReadDirArgs<'a> {
  #[inline]
  fn default() -> Self {
    ReadDirArgs { path: None }
  }
}
pub struct ReadDirBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReadDirBuilder<'a, 'b> {
  #[inline]
  pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadDir::VT_PATH, path);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> ReadDirBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReadDirBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReadDir<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ReadDirResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ReadDirRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadDirRes<'a> {
  type Inner = ReadDirRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> ReadDirRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReadDirRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ReadDirResArgs<'args>,
  ) -> flatbuffers::WIPOffset<ReadDirRes<'bldr>> {
    let mut builder = ReadDirResBuilder::new(_fbb);
    if let Some(x) = args.entries {
      builder.add_entries(x);
    }
    builder.finish()
  }

  pub const VT_ENTRIES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn entries(
    &self,
  ) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<StatRes<'a>>>>
  {
    self._tab.get::<flatbuffers::ForwardsUOffset<
      flatbuffers::Vector<flatbuffers::ForwardsUOffset<StatRes<'a>>>,
    >>(ReadDirRes::VT_ENTRIES, None)
  }
}

pub struct ReadDirResArgs<'a> {
  pub entries: Option<
    flatbuffers::WIPOffset<
      flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StatRes<'a>>>,
    >,
  >,
}
impl<'a> Default for ReadDirResArgs<'a> {
  #[inline]
  fn default() -> Self {
    ReadDirResArgs { entries: None }
  }
}
pub struct ReadDirResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReadDirResBuilder<'a, 'b> {
  #[inline]
  pub fn add_entries(
    &mut self,
    entries: flatbuffers::WIPOffset<
      flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<StatRes<'b>>>,
    >,
  ) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      ReadDirRes::VT_ENTRIES,
      entries,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> ReadDirResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReadDirResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReadDirRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum CopyFileOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CopyFile<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CopyFile<'a> {
  type Inner = CopyFile<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> CopyFile<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CopyFile { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CopyFileArgs<'args>,
  ) -> flatbuffers::WIPOffset<CopyFile<'bldr>> {
    let mut builder = CopyFileBuilder::new(_fbb);
    if let Some(x) = args.to {
      builder.add_to(x);
    }
    if let Some(x) = args.from {
      builder.add_from(x);
    }
    builder.finish()
  }

  pub const VT_FROM: flatbuffers::VOffsetT = 4;
  pub const VT_TO: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn from(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(CopyFile::VT_FROM, None)
  }
  #[inline]
  pub fn to(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(CopyFile::VT_TO, None)
  }
}

pub struct CopyFileArgs<'a> {
  pub from: Option<flatbuffers::WIPOffset<&'a str>>,
  pub to: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CopyFileArgs<'a> {
  #[inline]
  fn default() -> Self {
    CopyFileArgs {
      from: None,
      to: None,
    }
  }
}
pub struct CopyFileBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CopyFileBuilder<'a, 'b> {
  #[inline]
  pub fn add_from(&mut self, from: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(CopyFile::VT_FROM, from);
  }
  #[inline]
  pub fn add_to(&mut self, to: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(CopyFile::VT_TO, to);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> CopyFileBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CopyFileBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CopyFile<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RenameOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Rename<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Rename<'a> {
  type Inner = Rename<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Rename<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Rename { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RenameArgs<'args>,
  ) -> flatbuffers::WIPOffset<Rename<'bldr>> {
    let mut builder = RenameBuilder::new(_fbb);
    if let Some(x) = args.newpath {
      builder.add_newpath(x);
    }
    if let Some(x) = args.oldpath {
      builder.add_oldpath(x);
    }
    builder.finish()
  }

  pub const VT_OLDPATH: flatbuffers::VOffsetT = 4;
  pub const VT_NEWPATH: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn oldpath(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Rename::VT_OLDPATH, None)
  }
  #[inline]
  pub fn newpath(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Rename::VT_NEWPATH, None)
  }
}

pub struct RenameArgs<'a> {
  pub oldpath: Option<flatbuffers::WIPOffset<&'a str>>,
  pub newpath: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for RenameArgs<'a> {
  #[inline]
  fn default() -> Self {
    RenameArgs {
      oldpath: None,
      newpath: None,
    }
  }
}
pub struct RenameBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RenameBuilder<'a, 'b> {
  #[inline]
  pub fn add_oldpath(&mut self, oldpath: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      Rename::VT_OLDPATH,
      oldpath,
    );
  }
  #[inline]
  pub fn add_newpath(&mut self, newpath: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      Rename::VT_NEWPATH,
      newpath,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> RenameBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RenameBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Rename<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ReadlinkOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Readlink<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Readlink<'a> {
  type Inner = Readlink<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Readlink<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Readlink { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ReadlinkArgs<'args>,
  ) -> flatbuffers::WIPOffset<Readlink<'bldr>> {
    let mut builder = ReadlinkBuilder::new(_fbb);
    if let Some(x) = args.name {
      builder.add_name(x);
    }
    builder.finish()
  }

  pub const VT_NAME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Readlink::VT_NAME, None)
  }
}

pub struct ReadlinkArgs<'a> {
  pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ReadlinkArgs<'a> {
  #[inline]
  fn default() -> Self {
    ReadlinkArgs { name: None }
  }
}
pub struct ReadlinkBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReadlinkBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(Readlink::VT_NAME, name);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> ReadlinkBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReadlinkBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Readlink<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ReadlinkResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ReadlinkRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadlinkRes<'a> {
  type Inner = ReadlinkRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> ReadlinkRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReadlinkRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ReadlinkResArgs<'args>,
  ) -> flatbuffers::WIPOffset<ReadlinkRes<'bldr>> {
    let mut builder = ReadlinkResBuilder::new(_fbb);
    if let Some(x) = args.path {
      builder.add_path(x);
    }
    builder.finish()
  }

  pub const VT_PATH: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn path(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(ReadlinkRes::VT_PATH, None)
  }
}

pub struct ReadlinkResArgs<'a> {
  pub path: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ReadlinkResArgs<'a> {
  #[inline]
  fn default() -> Self {
    ReadlinkResArgs { path: None }
  }
}
pub struct ReadlinkResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReadlinkResBuilder<'a, 'b> {
  #[inline]
  pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      ReadlinkRes::VT_PATH,
      path,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> ReadlinkResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReadlinkResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReadlinkRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ReplStartOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ReplStart<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReplStart<'a> {
  type Inner = ReplStart<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> ReplStart<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReplStart { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ReplStartArgs<'args>,
  ) -> flatbuffers::WIPOffset<ReplStart<'bldr>> {
    let mut builder = ReplStartBuilder::new(_fbb);
    if let Some(x) = args.history_file {
      builder.add_history_file(x);
    }
    builder.finish()
  }

  pub const VT_HISTORY_FILE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn history_file(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
      ReplStart::VT_HISTORY_FILE,
      None,
    )
  }
}

pub struct ReplStartArgs<'a> {
  pub history_file: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ReplStartArgs<'a> {
  #[inline]
  fn default() -> Self {
    ReplStartArgs { history_file: None }
  }
}
pub struct ReplStartBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReplStartBuilder<'a, 'b> {
  #[inline]
  pub fn add_history_file(
    &mut self,
    history_file: flatbuffers::WIPOffset<&'b str>,
  ) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      ReplStart::VT_HISTORY_FILE,
      history_file,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> ReplStartBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReplStartBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReplStart<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ReplStartResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ReplStartRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReplStartRes<'a> {
  type Inner = ReplStartRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> ReplStartRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReplStartRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ReplStartResArgs,
  ) -> flatbuffers::WIPOffset<ReplStartRes<'bldr>> {
    let mut builder = ReplStartResBuilder::new(_fbb);
    builder.add_rid(args.rid);
    builder.finish()
  }

  pub const VT_RID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn rid(&self) -> u32 {
    self._tab.get::<u32>(ReplStartRes::VT_RID, Some(0)).unwrap()
  }
}

pub struct ReplStartResArgs {
  pub rid: u32,
}
impl<'a> Default for ReplStartResArgs {
  #[inline]
  fn default() -> Self {
    ReplStartResArgs { rid: 0 }
  }
}
pub struct ReplStartResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReplStartResBuilder<'a, 'b> {
  #[inline]
  pub fn add_rid(&mut self, rid: u32) {
    self.fbb_.push_slot::<u32>(ReplStartRes::VT_RID, rid, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> ReplStartResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReplStartResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReplStartRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ReplReadlineOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ReplReadline<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReplReadline<'a> {
  type Inner = ReplReadline<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> ReplReadline<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReplReadline { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ReplReadlineArgs<'args>,
  ) -> flatbuffers::WIPOffset<ReplReadline<'bldr>> {
    let mut builder = ReplReadlineBuilder::new(_fbb);
    if let Some(x) = args.prompt {
      builder.add_prompt(x);
    }
    builder.add_rid(args.rid);
    builder.finish()
  }

  pub const VT_RID: flatbuffers::VOffsetT = 4;
  pub const VT_PROMPT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn rid(&self) -> u32 {
    self._tab.get::<u32>(ReplReadline::VT_RID, Some(0)).unwrap()
  }
  #[inline]
  pub fn prompt(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(ReplReadline::VT_PROMPT, None)
  }
}

pub struct ReplReadlineArgs<'a> {
  pub rid: u32,
  pub prompt: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ReplReadlineArgs<'a> {
  #[inline]
  fn default() -> Self {
    ReplReadlineArgs {
      rid: 0,
      prompt: None,
    }
  }
}
pub struct ReplReadlineBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReplReadlineBuilder<'a, 'b> {
  #[inline]
  pub fn add_rid(&mut self, rid: u32) {
    self.fbb_.push_slot::<u32>(ReplReadline::VT_RID, rid, 0);
  }
  #[inline]
  pub fn add_prompt(&mut self, prompt: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      ReplReadline::VT_PROMPT,
      prompt,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> ReplReadlineBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReplReadlineBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReplReadline<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ReplReadlineResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ReplReadlineRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReplReadlineRes<'a> {
  type Inner = ReplReadlineRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> ReplReadlineRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReplReadlineRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ReplReadlineResArgs<'args>,
  ) -> flatbuffers::WIPOffset<ReplReadlineRes<'bldr>> {
    let mut builder = ReplReadlineResBuilder::new(_fbb);
    if let Some(x) = args.line {
      builder.add_line(x);
    }
    builder.finish()
  }

  pub const VT_LINE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn line(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(ReplReadlineRes::VT_LINE, None)
  }
}

pub struct ReplReadlineResArgs<'a> {
  pub line: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ReplReadlineResArgs<'a> {
  #[inline]
  fn default() -> Self {
    ReplReadlineResArgs { line: None }
  }
}
pub struct ReplReadlineResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReplReadlineResBuilder<'a, 'b> {
  #[inline]
  pub fn add_line(&mut self, line: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      ReplReadlineRes::VT_LINE,
      line,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> ReplReadlineResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReplReadlineResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReplReadlineRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ResourcesOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Resources<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Resources<'a> {
  type Inner = Resources<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Resources<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Resources { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args ResourcesArgs,
  ) -> flatbuffers::WIPOffset<Resources<'bldr>> {
    let mut builder = ResourcesBuilder::new(_fbb);
    builder.finish()
  }
}

pub struct ResourcesArgs {}
impl<'a> Default for ResourcesArgs {
  #[inline]
  fn default() -> Self {
    ResourcesArgs {}
  }
}
pub struct ResourcesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ResourcesBuilder<'a, 'b> {
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> ResourcesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ResourcesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Resources<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ResourceOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Resource<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Resource<'a> {
  type Inner = Resource<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Resource<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Resource { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ResourceArgs<'args>,
  ) -> flatbuffers::WIPOffset<Resource<'bldr>> {
    let mut builder = ResourceBuilder::new(_fbb);
    if let Some(x) = args.repr {
      builder.add_repr(x);
    }
    builder.add_rid(args.rid);
    builder.finish()
  }

  pub const VT_RID: flatbuffers::VOffsetT = 4;
  pub const VT_REPR: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn rid(&self) -> u32 {
    self._tab.get::<u32>(Resource::VT_RID, Some(0)).unwrap()
  }
  #[inline]
  pub fn repr(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Resource::VT_REPR, None)
  }
}

pub struct ResourceArgs<'a> {
  pub rid: u32,
  pub repr: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ResourceArgs<'a> {
  #[inline]
  fn default() -> Self {
    ResourceArgs { rid: 0, repr: None }
  }
}
pub struct ResourceBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ResourceBuilder<'a, 'b> {
  #[inline]
  pub fn add_rid(&mut self, rid: u32) {
    self.fbb_.push_slot::<u32>(Resource::VT_RID, rid, 0);
  }
  #[inline]
  pub fn add_repr(&mut self, repr: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(Resource::VT_REPR, repr);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> ResourceBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ResourceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Resource<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ResourcesResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ResourcesRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ResourcesRes<'a> {
  type Inner = ResourcesRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> ResourcesRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ResourcesRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ResourcesResArgs<'args>,
  ) -> flatbuffers::WIPOffset<ResourcesRes<'bldr>> {
    let mut builder = ResourcesResBuilder::new(_fbb);
    if let Some(x) = args.resources {
      builder.add_resources(x);
    }
    builder.finish()
  }

  pub const VT_RESOURCES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn resources(
    &self,
  ) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Resource<'a>>>>
  {
    self._tab.get::<flatbuffers::ForwardsUOffset<
      flatbuffers::Vector<flatbuffers::ForwardsUOffset<Resource<'a>>>,
    >>(ResourcesRes::VT_RESOURCES, None)
  }
}

pub struct ResourcesResArgs<'a> {
  pub resources: Option<
    flatbuffers::WIPOffset<
      flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Resource<'a>>>,
    >,
  >,
}
impl<'a> Default for ResourcesResArgs<'a> {
  #[inline]
  fn default() -> Self {
    ResourcesResArgs { resources: None }
  }
}
pub struct ResourcesResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ResourcesResBuilder<'a, 'b> {
  #[inline]
  pub fn add_resources(
    &mut self,
    resources: flatbuffers::WIPOffset<
      flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Resource<'b>>>,
    >,
  ) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      ResourcesRes::VT_RESOURCES,
      resources,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> ResourcesResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ResourcesResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ResourcesRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum SymlinkOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Symlink<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Symlink<'a> {
  type Inner = Symlink<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Symlink<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Symlink { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SymlinkArgs<'args>,
  ) -> flatbuffers::WIPOffset<Symlink<'bldr>> {
    let mut builder = SymlinkBuilder::new(_fbb);
    if let Some(x) = args.newname {
      builder.add_newname(x);
    }
    if let Some(x) = args.oldname {
      builder.add_oldname(x);
    }
    builder.finish()
  }

  pub const VT_OLDNAME: flatbuffers::VOffsetT = 4;
  pub const VT_NEWNAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn oldname(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Symlink::VT_OLDNAME, None)
  }
  #[inline]
  pub fn newname(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Symlink::VT_NEWNAME, None)
  }
}

pub struct SymlinkArgs<'a> {
  pub oldname: Option<flatbuffers::WIPOffset<&'a str>>,
  pub newname: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SymlinkArgs<'a> {
  #[inline]
  fn default() -> Self {
    SymlinkArgs {
      oldname: None,
      newname: None,
    }
  }
}
pub struct SymlinkBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SymlinkBuilder<'a, 'b> {
  #[inline]
  pub fn add_oldname(&mut self, oldname: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      Symlink::VT_OLDNAME,
      oldname,
    );
  }
  #[inline]
  pub fn add_newname(&mut self, newname: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      Symlink::VT_NEWNAME,
      newname,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> SymlinkBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SymlinkBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Symlink<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum LinkOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Link<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Link<'a> {
  type Inner = Link<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Link<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Link { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args LinkArgs<'args>,
  ) -> flatbuffers::WIPOffset<Link<'bldr>> {
    let mut builder = LinkBuilder::new(_fbb);
    if let Some(x) = args.newname {
      builder.add_newname(x);
    }
    if let Some(x) = args.oldname {
      builder.add_oldname(x);
    }
    builder.finish()
  }

  pub const VT_OLDNAME: flatbuffers::VOffsetT = 4;
  pub const VT_NEWNAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn oldname(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Link::VT_OLDNAME, None)
  }
  #[inline]
  pub fn newname(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Link::VT_NEWNAME, None)
  }
}

pub struct LinkArgs<'a> {
  pub oldname: Option<flatbuffers::WIPOffset<&'a str>>,
  pub newname: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for LinkArgs<'a> {
  #[inline]
  fn default() -> Self {
    LinkArgs {
      oldname: None,
      newname: None,
    }
  }
}
pub struct LinkBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LinkBuilder<'a, 'b> {
  #[inline]
  pub fn add_oldname(&mut self, oldname: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(Link::VT_OLDNAME, oldname);
  }
  #[inline]
  pub fn add_newname(&mut self, newname: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(Link::VT_NEWNAME, newname);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> LinkBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LinkBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Link<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum StatOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Stat<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Stat<'a> {
  type Inner = Stat<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Stat<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Stat { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args StatArgs<'args>,
  ) -> flatbuffers::WIPOffset<Stat<'bldr>> {
    let mut builder = StatBuilder::new(_fbb);
    if let Some(x) = args.filename {
      builder.add_filename(x);
    }
    builder.add_lstat(args.lstat);
    builder.finish()
  }

  pub const VT_FILENAME: flatbuffers::VOffsetT = 4;
  pub const VT_LSTAT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn filename(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Stat::VT_FILENAME, None)
  }
  #[inline]
  pub fn lstat(&self) -> bool {
    self._tab.get::<bool>(Stat::VT_LSTAT, Some(false)).unwrap()
  }
}

pub struct StatArgs<'a> {
  pub filename: Option<flatbuffers::WIPOffset<&'a str>>,
  pub lstat: bool,
}
impl<'a> Default for StatArgs<'a> {
  #[inline]
  fn default() -> Self {
    StatArgs {
      filename: None,
      lstat: false,
    }
  }
}
pub struct StatBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StatBuilder<'a, 'b> {
  #[inline]
  pub fn add_filename(&mut self, filename: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      Stat::VT_FILENAME,
      filename,
    );
  }
  #[inline]
  pub fn add_lstat(&mut self, lstat: bool) {
    self.fbb_.push_slot::<bool>(Stat::VT_LSTAT, lstat, false);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> StatBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StatBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Stat<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum StatResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StatRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StatRes<'a> {
  type Inner = StatRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> StatRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StatRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args StatResArgs<'args>,
  ) -> flatbuffers::WIPOffset<StatRes<'bldr>> {
    let mut builder = StatResBuilder::new(_fbb);
    builder.add_created(args.created);
    builder.add_accessed(args.accessed);
    builder.add_modified(args.modified);
    builder.add_len(args.len);
    if let Some(x) = args.name {
      builder.add_name(x);
    }
    builder.add_mode(args.mode);
    builder.add_has_mode(args.has_mode);
    builder.add_is_symlink(args.is_symlink);
    builder.add_is_file(args.is_file);
    builder.finish()
  }

  pub const VT_IS_FILE: flatbuffers::VOffsetT = 4;
  pub const VT_IS_SYMLINK: flatbuffers::VOffsetT = 6;
  pub const VT_LEN: flatbuffers::VOffsetT = 8;
  pub const VT_MODIFIED: flatbuffers::VOffsetT = 10;
  pub const VT_ACCESSED: flatbuffers::VOffsetT = 12;
  pub const VT_CREATED: flatbuffers::VOffsetT = 14;
  pub const VT_MODE: flatbuffers::VOffsetT = 16;
  pub const VT_HAS_MODE: flatbuffers::VOffsetT = 18;
  pub const VT_NAME: flatbuffers::VOffsetT = 20;

  #[inline]
  pub fn is_file(&self) -> bool {
    self
      ._tab
      .get::<bool>(StatRes::VT_IS_FILE, Some(false))
      .unwrap()
  }
  #[inline]
  pub fn is_symlink(&self) -> bool {
    self
      ._tab
      .get::<bool>(StatRes::VT_IS_SYMLINK, Some(false))
      .unwrap()
  }
  #[inline]
  pub fn len(&self) -> u64 {
    self._tab.get::<u64>(StatRes::VT_LEN, Some(0)).unwrap()
  }
  #[inline]
  pub fn modified(&self) -> u64 {
    self._tab.get::<u64>(StatRes::VT_MODIFIED, Some(0)).unwrap()
  }
  #[inline]
  pub fn accessed(&self) -> u64 {
    self._tab.get::<u64>(StatRes::VT_ACCESSED, Some(0)).unwrap()
  }
  #[inline]
  pub fn created(&self) -> u64 {
    self._tab.get::<u64>(StatRes::VT_CREATED, Some(0)).unwrap()
  }
  #[inline]
  pub fn mode(&self) -> u32 {
    self._tab.get::<u32>(StatRes::VT_MODE, Some(0)).unwrap()
  }
  #[inline]
  pub fn has_mode(&self) -> bool {
    self
      ._tab
      .get::<bool>(StatRes::VT_HAS_MODE, Some(false))
      .unwrap()
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(StatRes::VT_NAME, None)
  }
}

pub struct StatResArgs<'a> {
  pub is_file: bool,
  pub is_symlink: bool,
  pub len: u64,
  pub modified: u64,
  pub accessed: u64,
  pub created: u64,
  pub mode: u32,
  pub has_mode: bool,
  pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for StatResArgs<'a> {
  #[inline]
  fn default() -> Self {
    StatResArgs {
      is_file: false,
      is_symlink: false,
      len: 0,
      modified: 0,
      accessed: 0,
      created: 0,
      mode: 0,
      has_mode: false,
      name: None,
    }
  }
}
pub struct StatResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StatResBuilder<'a, 'b> {
  #[inline]
  pub fn add_is_file(&mut self, is_file: bool) {
    self
      .fbb_
      .push_slot::<bool>(StatRes::VT_IS_FILE, is_file, false);
  }
  #[inline]
  pub fn add_is_symlink(&mut self, is_symlink: bool) {
    self
      .fbb_
      .push_slot::<bool>(StatRes::VT_IS_SYMLINK, is_symlink, false);
  }
  #[inline]
  pub fn add_len(&mut self, len: u64) {
    self.fbb_.push_slot::<u64>(StatRes::VT_LEN, len, 0);
  }
  #[inline]
  pub fn add_modified(&mut self, modified: u64) {
    self
      .fbb_
      .push_slot::<u64>(StatRes::VT_MODIFIED, modified, 0);
  }
  #[inline]
  pub fn add_accessed(&mut self, accessed: u64) {
    self
      .fbb_
      .push_slot::<u64>(StatRes::VT_ACCESSED, accessed, 0);
  }
  #[inline]
  pub fn add_created(&mut self, created: u64) {
    self.fbb_.push_slot::<u64>(StatRes::VT_CREATED, created, 0);
  }
  #[inline]
  pub fn add_mode(&mut self, mode: u32) {
    self.fbb_.push_slot::<u32>(StatRes::VT_MODE, mode, 0);
  }
  #[inline]
  pub fn add_has_mode(&mut self, has_mode: bool) {
    self
      .fbb_
      .push_slot::<bool>(StatRes::VT_HAS_MODE, has_mode, false);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(StatRes::VT_NAME, name);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> StatResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StatResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StatRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum TruncateOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Truncate<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Truncate<'a> {
  type Inner = Truncate<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Truncate<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Truncate { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TruncateArgs<'args>,
  ) -> flatbuffers::WIPOffset<Truncate<'bldr>> {
    let mut builder = TruncateBuilder::new(_fbb);
    builder.add_len(args.len);
    if let Some(x) = args.name {
      builder.add_name(x);
    }
    builder.finish()
  }

  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_LEN: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Truncate::VT_NAME, None)
  }
  #[inline]
  pub fn len(&self) -> u32 {
    self._tab.get::<u32>(Truncate::VT_LEN, Some(0)).unwrap()
  }
}

pub struct TruncateArgs<'a> {
  pub name: Option<flatbuffers::WIPOffset<&'a str>>,
  pub len: u32,
}
impl<'a> Default for TruncateArgs<'a> {
  #[inline]
  fn default() -> Self {
    TruncateArgs { name: None, len: 0 }
  }
}
pub struct TruncateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TruncateBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(Truncate::VT_NAME, name);
  }
  #[inline]
  pub fn add_len(&mut self, len: u32) {
    self.fbb_.push_slot::<u32>(Truncate::VT_LEN, len, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> TruncateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TruncateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Truncate<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum HomeDirOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct HomeDir<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HomeDir<'a> {
  type Inner = HomeDir<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> HomeDir<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HomeDir { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args HomeDirArgs,
  ) -> flatbuffers::WIPOffset<HomeDir<'bldr>> {
    let mut builder = HomeDirBuilder::new(_fbb);
    builder.finish()
  }
}

pub struct HomeDirArgs {}
impl<'a> Default for HomeDirArgs {
  #[inline]
  fn default() -> Self {
    HomeDirArgs {}
  }
}
pub struct HomeDirBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HomeDirBuilder<'a, 'b> {
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> HomeDirBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HomeDirBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HomeDir<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum HomeDirResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct HomeDirRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HomeDirRes<'a> {
  type Inner = HomeDirRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> HomeDirRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HomeDirRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args HomeDirResArgs<'args>,
  ) -> flatbuffers::WIPOffset<HomeDirRes<'bldr>> {
    let mut builder = HomeDirResBuilder::new(_fbb);
    if let Some(x) = args.path {
      builder.add_path(x);
    }
    builder.finish()
  }

  pub const VT_PATH: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn path(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(HomeDirRes::VT_PATH, None)
  }
}

pub struct HomeDirResArgs<'a> {
  pub path: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for HomeDirResArgs<'a> {
  #[inline]
  fn default() -> Self {
    HomeDirResArgs { path: None }
  }
}
pub struct HomeDirResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HomeDirResBuilder<'a, 'b> {
  #[inline]
  pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(HomeDirRes::VT_PATH, path);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> HomeDirResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HomeDirResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HomeDirRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ExecPathOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ExecPath<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExecPath<'a> {
  type Inner = ExecPath<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> ExecPath<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ExecPath { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args ExecPathArgs,
  ) -> flatbuffers::WIPOffset<ExecPath<'bldr>> {
    let mut builder = ExecPathBuilder::new(_fbb);
    builder.finish()
  }
}

pub struct ExecPathArgs {}
impl<'a> Default for ExecPathArgs {
  #[inline]
  fn default() -> Self {
    ExecPathArgs {}
  }
}
pub struct ExecPathBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExecPathBuilder<'a, 'b> {
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> ExecPathBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ExecPathBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ExecPath<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ExecPathResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ExecPathRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExecPathRes<'a> {
  type Inner = ExecPathRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> ExecPathRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ExecPathRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ExecPathResArgs<'args>,
  ) -> flatbuffers::WIPOffset<ExecPathRes<'bldr>> {
    let mut builder = ExecPathResBuilder::new(_fbb);
    if let Some(x) = args.path {
      builder.add_path(x);
    }
    builder.finish()
  }

  pub const VT_PATH: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn path(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(ExecPathRes::VT_PATH, None)
  }
}

pub struct ExecPathResArgs<'a> {
  pub path: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ExecPathResArgs<'a> {
  #[inline]
  fn default() -> Self {
    ExecPathResArgs { path: None }
  }
}
pub struct ExecPathResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExecPathResBuilder<'a, 'b> {
  #[inline]
  pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      ExecPathRes::VT_PATH,
      path,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> ExecPathResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ExecPathResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ExecPathRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum UtimeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Utime<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Utime<'a> {
  type Inner = Utime<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Utime<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Utime { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UtimeArgs<'args>,
  ) -> flatbuffers::WIPOffset<Utime<'bldr>> {
    let mut builder = UtimeBuilder::new(_fbb);
    builder.add_mtime(args.mtime);
    builder.add_atime(args.atime);
    if let Some(x) = args.filename {
      builder.add_filename(x);
    }
    builder.finish()
  }

  pub const VT_FILENAME: flatbuffers::VOffsetT = 4;
  pub const VT_ATIME: flatbuffers::VOffsetT = 6;
  pub const VT_MTIME: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn filename(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Utime::VT_FILENAME, None)
  }
  #[inline]
  pub fn atime(&self) -> u64 {
    self._tab.get::<u64>(Utime::VT_ATIME, Some(0)).unwrap()
  }
  #[inline]
  pub fn mtime(&self) -> u64 {
    self._tab.get::<u64>(Utime::VT_MTIME, Some(0)).unwrap()
  }
}

pub struct UtimeArgs<'a> {
  pub filename: Option<flatbuffers::WIPOffset<&'a str>>,
  pub atime: u64,
  pub mtime: u64,
}
impl<'a> Default for UtimeArgs<'a> {
  #[inline]
  fn default() -> Self {
    UtimeArgs {
      filename: None,
      atime: 0,
      mtime: 0,
    }
  }
}
pub struct UtimeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UtimeBuilder<'a, 'b> {
  #[inline]
  pub fn add_filename(&mut self, filename: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      Utime::VT_FILENAME,
      filename,
    );
  }
  #[inline]
  pub fn add_atime(&mut self, atime: u64) {
    self.fbb_.push_slot::<u64>(Utime::VT_ATIME, atime, 0);
  }
  #[inline]
  pub fn add_mtime(&mut self, mtime: u64) {
    self.fbb_.push_slot::<u64>(Utime::VT_MTIME, mtime, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> UtimeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UtimeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Utime<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum OpenOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Open<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Open<'a> {
  type Inner = Open<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Open<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Open { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args OpenArgs<'args>,
  ) -> flatbuffers::WIPOffset<Open<'bldr>> {
    let mut builder = OpenBuilder::new(_fbb);
    if let Some(x) = args.mode {
      builder.add_mode(x);
    }
    builder.add_perm(args.perm);
    if let Some(x) = args.filename {
      builder.add_filename(x);
    }
    builder.finish()
  }

  pub const VT_FILENAME: flatbuffers::VOffsetT = 4;
  pub const VT_PERM: flatbuffers::VOffsetT = 6;
  pub const VT_MODE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn filename(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Open::VT_FILENAME, None)
  }
  #[inline]
  pub fn perm(&self) -> u32 {
    self._tab.get::<u32>(Open::VT_PERM, Some(0)).unwrap()
  }
  #[inline]
  pub fn mode(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Open::VT_MODE, None)
  }
}

pub struct OpenArgs<'a> {
  pub filename: Option<flatbuffers::WIPOffset<&'a str>>,
  pub perm: u32,
  pub mode: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for OpenArgs<'a> {
  #[inline]
  fn default() -> Self {
    OpenArgs {
      filename: None,
      perm: 0,
      mode: None,
    }
  }
}
pub struct OpenBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OpenBuilder<'a, 'b> {
  #[inline]
  pub fn add_filename(&mut self, filename: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      Open::VT_FILENAME,
      filename,
    );
  }
  #[inline]
  pub fn add_perm(&mut self, perm: u32) {
    self.fbb_.push_slot::<u32>(Open::VT_PERM, perm, 0);
  }
  #[inline]
  pub fn add_mode(&mut self, mode: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(Open::VT_MODE, mode);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> OpenBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OpenBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Open<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum OpenResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct OpenRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OpenRes<'a> {
  type Inner = OpenRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> OpenRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OpenRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args OpenResArgs,
  ) -> flatbuffers::WIPOffset<OpenRes<'bldr>> {
    let mut builder = OpenResBuilder::new(_fbb);
    builder.add_rid(args.rid);
    builder.finish()
  }

  pub const VT_RID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn rid(&self) -> u32 {
    self._tab.get::<u32>(OpenRes::VT_RID, Some(0)).unwrap()
  }
}

pub struct OpenResArgs {
  pub rid: u32,
}
impl<'a> Default for OpenResArgs {
  #[inline]
  fn default() -> Self {
    OpenResArgs { rid: 0 }
  }
}
pub struct OpenResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OpenResBuilder<'a, 'b> {
  #[inline]
  pub fn add_rid(&mut self, rid: u32) {
    self.fbb_.push_slot::<u32>(OpenRes::VT_RID, rid, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> OpenResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OpenResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OpenRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ReadOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Read<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Read<'a> {
  type Inner = Read<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Read<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Read { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ReadArgs,
  ) -> flatbuffers::WIPOffset<Read<'bldr>> {
    let mut builder = ReadBuilder::new(_fbb);
    builder.add_rid(args.rid);
    builder.finish()
  }

  pub const VT_RID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn rid(&self) -> u32 {
    self._tab.get::<u32>(Read::VT_RID, Some(0)).unwrap()
  }
}

pub struct ReadArgs {
  pub rid: u32,
}
impl<'a> Default for ReadArgs {
  #[inline]
  fn default() -> Self {
    ReadArgs { rid: 0 }
  }
}
pub struct ReadBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReadBuilder<'a, 'b> {
  #[inline]
  pub fn add_rid(&mut self, rid: u32) {
    self.fbb_.push_slot::<u32>(Read::VT_RID, rid, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> ReadBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReadBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Read<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ReadResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ReadRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadRes<'a> {
  type Inner = ReadRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> ReadRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReadRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ReadResArgs,
  ) -> flatbuffers::WIPOffset<ReadRes<'bldr>> {
    let mut builder = ReadResBuilder::new(_fbb);
    builder.add_nread(args.nread);
    builder.add_eof(args.eof);
    builder.finish()
  }

  pub const VT_NREAD: flatbuffers::VOffsetT = 4;
  pub const VT_EOF: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn nread(&self) -> u32 {
    self._tab.get::<u32>(ReadRes::VT_NREAD, Some(0)).unwrap()
  }
  #[inline]
  pub fn eof(&self) -> bool {
    self._tab.get::<bool>(ReadRes::VT_EOF, Some(false)).unwrap()
  }
}

pub struct ReadResArgs {
  pub nread: u32,
  pub eof: bool,
}
impl<'a> Default for ReadResArgs {
  #[inline]
  fn default() -> Self {
    ReadResArgs {
      nread: 0,
      eof: false,
    }
  }
}
pub struct ReadResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReadResBuilder<'a, 'b> {
  #[inline]
  pub fn add_nread(&mut self, nread: u32) {
    self.fbb_.push_slot::<u32>(ReadRes::VT_NREAD, nread, 0);
  }
  #[inline]
  pub fn add_eof(&mut self, eof: bool) {
    self.fbb_.push_slot::<bool>(ReadRes::VT_EOF, eof, false);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> ReadResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReadResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReadRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum WriteOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Write<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Write<'a> {
  type Inner = Write<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Write<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Write { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args WriteArgs,
  ) -> flatbuffers::WIPOffset<Write<'bldr>> {
    let mut builder = WriteBuilder::new(_fbb);
    builder.add_rid(args.rid);
    builder.finish()
  }

  pub const VT_RID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn rid(&self) -> u32 {
    self._tab.get::<u32>(Write::VT_RID, Some(0)).unwrap()
  }
}

pub struct WriteArgs {
  pub rid: u32,
}
impl<'a> Default for WriteArgs {
  #[inline]
  fn default() -> Self {
    WriteArgs { rid: 0 }
  }
}
pub struct WriteBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WriteBuilder<'a, 'b> {
  #[inline]
  pub fn add_rid(&mut self, rid: u32) {
    self.fbb_.push_slot::<u32>(Write::VT_RID, rid, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> WriteBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WriteBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Write<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum WriteResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct WriteRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WriteRes<'a> {
  type Inner = WriteRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> WriteRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WriteRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args WriteResArgs,
  ) -> flatbuffers::WIPOffset<WriteRes<'bldr>> {
    let mut builder = WriteResBuilder::new(_fbb);
    builder.add_nbyte(args.nbyte);
    builder.finish()
  }

  pub const VT_NBYTE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn nbyte(&self) -> u32 {
    self._tab.get::<u32>(WriteRes::VT_NBYTE, Some(0)).unwrap()
  }
}

pub struct WriteResArgs {
  pub nbyte: u32,
}
impl<'a> Default for WriteResArgs {
  #[inline]
  fn default() -> Self {
    WriteResArgs { nbyte: 0 }
  }
}
pub struct WriteResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WriteResBuilder<'a, 'b> {
  #[inline]
  pub fn add_nbyte(&mut self, nbyte: u32) {
    self.fbb_.push_slot::<u32>(WriteRes::VT_NBYTE, nbyte, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> WriteResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WriteResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WriteRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum CloseOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Close<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Close<'a> {
  type Inner = Close<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Close<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Close { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CloseArgs,
  ) -> flatbuffers::WIPOffset<Close<'bldr>> {
    let mut builder = CloseBuilder::new(_fbb);
    builder.add_rid(args.rid);
    builder.finish()
  }

  pub const VT_RID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn rid(&self) -> u32 {
    self._tab.get::<u32>(Close::VT_RID, Some(0)).unwrap()
  }
}

pub struct CloseArgs {
  pub rid: u32,
}
impl<'a> Default for CloseArgs {
  #[inline]
  fn default() -> Self {
    CloseArgs { rid: 0 }
  }
}
pub struct CloseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CloseBuilder<'a, 'b> {
  #[inline]
  pub fn add_rid(&mut self, rid: u32) {
    self.fbb_.push_slot::<u32>(Close::VT_RID, rid, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> CloseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CloseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Close<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum KillOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Kill<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kill<'a> {
  type Inner = Kill<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Kill<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kill { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args KillArgs,
  ) -> flatbuffers::WIPOffset<Kill<'bldr>> {
    let mut builder = KillBuilder::new(_fbb);
    builder.add_signo(args.signo);
    builder.add_pid(args.pid);
    builder.finish()
  }

  pub const VT_PID: flatbuffers::VOffsetT = 4;
  pub const VT_SIGNO: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn pid(&self) -> i32 {
    self._tab.get::<i32>(Kill::VT_PID, Some(0)).unwrap()
  }
  #[inline]
  pub fn signo(&self) -> i32 {
    self._tab.get::<i32>(Kill::VT_SIGNO, Some(0)).unwrap()
  }
}

pub struct KillArgs {
  pub pid: i32,
  pub signo: i32,
}
impl<'a> Default for KillArgs {
  #[inline]
  fn default() -> Self {
    KillArgs { pid: 0, signo: 0 }
  }
}
pub struct KillBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> KillBuilder<'a, 'b> {
  #[inline]
  pub fn add_pid(&mut self, pid: i32) {
    self.fbb_.push_slot::<i32>(Kill::VT_PID, pid, 0);
  }
  #[inline]
  pub fn add_signo(&mut self, signo: i32) {
    self.fbb_.push_slot::<i32>(Kill::VT_SIGNO, signo, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> KillBuilder<'a, 'b> {
    let start = _fbb.start_table();
    KillBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kill<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ShutdownOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Shutdown<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Shutdown<'a> {
  type Inner = Shutdown<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Shutdown<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Shutdown { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ShutdownArgs,
  ) -> flatbuffers::WIPOffset<Shutdown<'bldr>> {
    let mut builder = ShutdownBuilder::new(_fbb);
    builder.add_how(args.how);
    builder.add_rid(args.rid);
    builder.finish()
  }

  pub const VT_RID: flatbuffers::VOffsetT = 4;
  pub const VT_HOW: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn rid(&self) -> u32 {
    self._tab.get::<u32>(Shutdown::VT_RID, Some(0)).unwrap()
  }
  #[inline]
  pub fn how(&self) -> u32 {
    self._tab.get::<u32>(Shutdown::VT_HOW, Some(0)).unwrap()
  }
}

pub struct ShutdownArgs {
  pub rid: u32,
  pub how: u32,
}
impl<'a> Default for ShutdownArgs {
  #[inline]
  fn default() -> Self {
    ShutdownArgs { rid: 0, how: 0 }
  }
}
pub struct ShutdownBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ShutdownBuilder<'a, 'b> {
  #[inline]
  pub fn add_rid(&mut self, rid: u32) {
    self.fbb_.push_slot::<u32>(Shutdown::VT_RID, rid, 0);
  }
  #[inline]
  pub fn add_how(&mut self, how: u32) {
    self.fbb_.push_slot::<u32>(Shutdown::VT_HOW, how, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> ShutdownBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ShutdownBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Shutdown<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ListenOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Listen<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Listen<'a> {
  type Inner = Listen<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Listen<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Listen { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ListenArgs<'args>,
  ) -> flatbuffers::WIPOffset<Listen<'bldr>> {
    let mut builder = ListenBuilder::new(_fbb);
    if let Some(x) = args.address {
      builder.add_address(x);
    }
    if let Some(x) = args.network {
      builder.add_network(x);
    }
    builder.finish()
  }

  pub const VT_NETWORK: flatbuffers::VOffsetT = 4;
  pub const VT_ADDRESS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn network(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Listen::VT_NETWORK, None)
  }
  #[inline]
  pub fn address(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Listen::VT_ADDRESS, None)
  }
}

pub struct ListenArgs<'a> {
  pub network: Option<flatbuffers::WIPOffset<&'a str>>,
  pub address: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ListenArgs<'a> {
  #[inline]
  fn default() -> Self {
    ListenArgs {
      network: None,
      address: None,
    }
  }
}
pub struct ListenBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ListenBuilder<'a, 'b> {
  #[inline]
  pub fn add_network(&mut self, network: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      Listen::VT_NETWORK,
      network,
    );
  }
  #[inline]
  pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      Listen::VT_ADDRESS,
      address,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> ListenBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ListenBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Listen<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ListenResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ListenRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ListenRes<'a> {
  type Inner = ListenRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> ListenRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ListenRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ListenResArgs,
  ) -> flatbuffers::WIPOffset<ListenRes<'bldr>> {
    let mut builder = ListenResBuilder::new(_fbb);
    builder.add_rid(args.rid);
    builder.finish()
  }

  pub const VT_RID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn rid(&self) -> u32 {
    self._tab.get::<u32>(ListenRes::VT_RID, Some(0)).unwrap()
  }
}

pub struct ListenResArgs {
  pub rid: u32,
}
impl<'a> Default for ListenResArgs {
  #[inline]
  fn default() -> Self {
    ListenResArgs { rid: 0 }
  }
}
pub struct ListenResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ListenResBuilder<'a, 'b> {
  #[inline]
  pub fn add_rid(&mut self, rid: u32) {
    self.fbb_.push_slot::<u32>(ListenRes::VT_RID, rid, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> ListenResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ListenResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ListenRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum AcceptOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Accept<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Accept<'a> {
  type Inner = Accept<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Accept<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Accept { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AcceptArgs,
  ) -> flatbuffers::WIPOffset<Accept<'bldr>> {
    let mut builder = AcceptBuilder::new(_fbb);
    builder.add_rid(args.rid);
    builder.finish()
  }

  pub const VT_RID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn rid(&self) -> u32 {
    self._tab.get::<u32>(Accept::VT_RID, Some(0)).unwrap()
  }
}

pub struct AcceptArgs {
  pub rid: u32,
}
impl<'a> Default for AcceptArgs {
  #[inline]
  fn default() -> Self {
    AcceptArgs { rid: 0 }
  }
}
pub struct AcceptBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AcceptBuilder<'a, 'b> {
  #[inline]
  pub fn add_rid(&mut self, rid: u32) {
    self.fbb_.push_slot::<u32>(Accept::VT_RID, rid, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> AcceptBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AcceptBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Accept<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum DialOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Dial<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Dial<'a> {
  type Inner = Dial<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Dial<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Dial { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DialArgs<'args>,
  ) -> flatbuffers::WIPOffset<Dial<'bldr>> {
    let mut builder = DialBuilder::new(_fbb);
    if let Some(x) = args.address {
      builder.add_address(x);
    }
    if let Some(x) = args.network {
      builder.add_network(x);
    }
    builder.finish()
  }

  pub const VT_NETWORK: flatbuffers::VOffsetT = 4;
  pub const VT_ADDRESS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn network(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Dial::VT_NETWORK, None)
  }
  #[inline]
  pub fn address(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Dial::VT_ADDRESS, None)
  }
}

pub struct DialArgs<'a> {
  pub network: Option<flatbuffers::WIPOffset<&'a str>>,
  pub address: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DialArgs<'a> {
  #[inline]
  fn default() -> Self {
    DialArgs {
      network: None,
      address: None,
    }
  }
}
pub struct DialBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DialBuilder<'a, 'b> {
  #[inline]
  pub fn add_network(&mut self, network: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(Dial::VT_NETWORK, network);
  }
  #[inline]
  pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(Dial::VT_ADDRESS, address);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> DialBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DialBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Dial<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum NewConnOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct NewConn<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NewConn<'a> {
  type Inner = NewConn<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> NewConn<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NewConn { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args NewConnArgs<'args>,
  ) -> flatbuffers::WIPOffset<NewConn<'bldr>> {
    let mut builder = NewConnBuilder::new(_fbb);
    if let Some(x) = args.local_addr {
      builder.add_local_addr(x);
    }
    if let Some(x) = args.remote_addr {
      builder.add_remote_addr(x);
    }
    builder.add_rid(args.rid);
    builder.finish()
  }

  pub const VT_RID: flatbuffers::VOffsetT = 4;
  pub const VT_REMOTE_ADDR: flatbuffers::VOffsetT = 6;
  pub const VT_LOCAL_ADDR: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn rid(&self) -> u32 {
    self._tab.get::<u32>(NewConn::VT_RID, Some(0)).unwrap()
  }
  #[inline]
  pub fn remote_addr(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(NewConn::VT_REMOTE_ADDR, None)
  }
  #[inline]
  pub fn local_addr(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(NewConn::VT_LOCAL_ADDR, None)
  }
}

pub struct NewConnArgs<'a> {
  pub rid: u32,
  pub remote_addr: Option<flatbuffers::WIPOffset<&'a str>>,
  pub local_addr: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for NewConnArgs<'a> {
  #[inline]
  fn default() -> Self {
    NewConnArgs {
      rid: 0,
      remote_addr: None,
      local_addr: None,
    }
  }
}
pub struct NewConnBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NewConnBuilder<'a, 'b> {
  #[inline]
  pub fn add_rid(&mut self, rid: u32) {
    self.fbb_.push_slot::<u32>(NewConn::VT_RID, rid, 0);
  }
  #[inline]
  pub fn add_remote_addr(
    &mut self,
    remote_addr: flatbuffers::WIPOffset<&'b str>,
  ) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      NewConn::VT_REMOTE_ADDR,
      remote_addr,
    );
  }
  #[inline]
  pub fn add_local_addr(
    &mut self,
    local_addr: flatbuffers::WIPOffset<&'b str>,
  ) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
      NewConn::VT_LOCAL_ADDR,
      local_addr,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> NewConnBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NewConnBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NewConn<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum MetricsOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Metrics<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Metrics<'a> {
  type Inner = Metrics<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Metrics<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Metrics { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args MetricsArgs,
  ) -> flatbuffers::WIPOffset<Metrics<'bldr>> {
    let mut builder = MetricsBuilder::new(_fbb);
    builder.finish()
  }
}

pub struct MetricsArgs {}
impl<'a> Default for MetricsArgs {
  #[inline]
  fn default() -> Self {
    MetricsArgs {}
  }
}
pub struct MetricsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MetricsBuilder<'a, 'b> {
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> MetricsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MetricsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Metrics<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum MetricsResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct MetricsRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MetricsRes<'a> {
  type Inner = MetricsRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> MetricsRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MetricsRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MetricsResArgs,
  ) -> flatbuffers::WIPOffset<MetricsRes<'bldr>> {
    let mut builder = MetricsResBuilder::new(_fbb);
    builder.add_bytes_received(args.bytes_received);
    builder.add_bytes_sent_data(args.bytes_sent_data);
    builder.add_bytes_sent_control(args.bytes_sent_control);
    builder.add_ops_completed(args.ops_completed);
    builder.add_ops_dispatched(args.ops_dispatched);
    builder.finish()
  }

  pub const VT_OPS_DISPATCHED: flatbuffers::VOffsetT = 4;
  pub const VT_OPS_COMPLETED: flatbuffers::VOffsetT = 6;
  pub const VT_BYTES_SENT_CONTROL: flatbuffers::VOffsetT = 8;
  pub const VT_BYTES_SENT_DATA: flatbuffers::VOffsetT = 10;
  pub const VT_BYTES_RECEIVED: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn ops_dispatched(&self) -> u64 {
    self
      ._tab
      .get::<u64>(MetricsRes::VT_OPS_DISPATCHED, Some(0))
      .unwrap()
  }
  #[inline]
  pub fn ops_completed(&self) -> u64 {
    self
      ._tab
      .get::<u64>(MetricsRes::VT_OPS_COMPLETED, Some(0))
      .unwrap()
  }
  #[inline]
  pub fn bytes_sent_control(&self) -> u64 {
    self
      ._tab
      .get::<u64>(MetricsRes::VT_BYTES_SENT_CONTROL, Some(0))
      .unwrap()
  }
  #[inline]
  pub fn bytes_sent_data(&self) -> u64 {
    self
      ._tab
      .get::<u64>(MetricsRes::VT_BYTES_SENT_DATA, Some(0))
      .unwrap()
  }
  #[inline]
  pub fn bytes_received(&self) -> u64 {
    self
      ._tab
      .get::<u64>(MetricsRes::VT_BYTES_RECEIVED, Some(0))
      .unwrap()
  }
}

pub struct MetricsResArgs {
  pub ops_dispatched: u64,
  pub ops_completed: u64,
  pub bytes_sent_control: u64,
  pub bytes_sent_data: u64,
  pub bytes_received: u64,
}
impl<'a> Default for MetricsResArgs {
  #[inline]
  fn default() -> Self {
    MetricsResArgs {
      ops_dispatched: 0,
      ops_completed: 0,
      bytes_sent_control: 0,
      bytes_sent_data: 0,
      bytes_received: 0,
    }
  }
}
pub struct MetricsResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MetricsResBuilder<'a, 'b> {
  #[inline]
  pub fn add_ops_dispatched(&mut self, ops_dispatched: u64) {
    self.fbb_.push_slot::<u64>(
      MetricsRes::VT_OPS_DISPATCHED,
      ops_dispatched,
      0,
    );
  }
  #[inline]
  pub fn add_ops_completed(&mut self, ops_completed: u64) {
    self
      .fbb_
      .push_slot::<u64>(MetricsRes::VT_OPS_COMPLETED, ops_completed, 0);
  }
  #[inline]
  pub fn add_bytes_sent_control(&mut self, bytes_sent_control: u64) {
    self.fbb_.push_slot::<u64>(
      MetricsRes::VT_BYTES_SENT_CONTROL,
      bytes_sent_control,
      0,
    );
  }
  #[inline]
  pub fn add_bytes_sent_data(&mut self, bytes_sent_data: u64) {
    self.fbb_.push_slot::<u64>(
      MetricsRes::VT_BYTES_SENT_DATA,
      bytes_sent_data,
      0,
    );
  }
  #[inline]
  pub fn add_bytes_received(&mut self, bytes_received: u64) {
    self.fbb_.push_slot::<u64>(
      MetricsRes::VT_BYTES_RECEIVED,
      bytes_received,
      0,
    );
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> MetricsResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MetricsResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MetricsRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RunOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Run<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Run<'a> {
  type Inner = Run<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Run<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Run { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RunArgs<'args>,
  ) -> flatbuffers::WIPOffset<Run<'bldr>> {
    let mut builder = RunBuilder::new(_fbb);
    builder.add_stderr_rid(args.stderr_rid);
    builder.add_stdout_rid(args.stdout_rid);
    builder.add_stdin_rid(args.stdin_rid);
    if let Some(x) = args.env {
      builder.add_env(x);
    }
    if let Some(x) = args.cwd {
      builder.add_cwd(x);
    }
    if let Some(x) = args.args {
      builder.add_args(x);
    }
    builder.add_stderr(args.stderr);
    builder.add_stdout(args.stdout);
    builder.add_stdin(args.stdin);
    builder.finish()
  }

  pub const VT_ARGS: flatbuffers::VOffsetT = 4;
  pub const VT_CWD: flatbuffers::VOffsetT = 6;
  pub const VT_ENV: flatbuffers::VOffsetT = 8;
  pub const VT_STDIN: flatbuffers::VOffsetT = 10;
  pub const VT_STDOUT: flatbuffers::VOffsetT = 12;
  pub const VT_STDERR: flatbuffers::VOffsetT = 14;
  pub const VT_STDIN_RID: flatbuffers::VOffsetT = 16;
  pub const VT_STDOUT_RID: flatbuffers::VOffsetT = 18;
  pub const VT_STDERR_RID: flatbuffers::VOffsetT = 20;

  #[inline]
  pub fn args(
    &self,
  ) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<
      flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>,
    >>(Run::VT_ARGS, None)
  }
  #[inline]
  pub fn cwd(&self) -> Option<&'a str> {
    self
      ._tab
      .get::<flatbuffers::ForwardsUOffset<&str>>(Run::VT_CWD, None)
  }
  #[inline]
  pub fn env(
    &self,
  ) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<KeyValue<'a>>>>
  {
    self._tab.get::<flatbuffers::ForwardsUOffset<
      flatbuffers::Vector<flatbuffers::ForwardsUOffset<KeyValue<'a>>>,
    >>(Run::VT_ENV, None)
  }
  #[inline]
  pub fn stdin(&self) -> ProcessStdio {
    self
      ._tab
      .get::<ProcessStdio>(Run::VT_STDIN, Some(ProcessStdio::Inherit))
      .unwrap()
  }
  #[inline]
  pub fn stdout(&self) -> ProcessStdio {
    self
      ._tab
      .get::<ProcessStdio>(Run::VT_STDOUT, Some(ProcessStdio::Inherit))
      .unwrap()
  }
  #[inline]
  pub fn stderr(&self) -> ProcessStdio {
    self
      ._tab
      .get::<ProcessStdio>(Run::VT_STDERR, Some(ProcessStdio::Inherit))
      .unwrap()
  }
  #[inline]
  pub fn stdin_rid(&self) -> u32 {
    self._tab.get::<u32>(Run::VT_STDIN_RID, Some(0)).unwrap()
  }
  #[inline]
  pub fn stdout_rid(&self) -> u32 {
    self._tab.get::<u32>(Run::VT_STDOUT_RID, Some(0)).unwrap()
  }
  #[inline]
  pub fn stderr_rid(&self) -> u32 {
    self._tab.get::<u32>(Run::VT_STDERR_RID, Some(0)).unwrap()
  }
}

pub struct RunArgs<'a> {
  pub args: Option<
    flatbuffers::WIPOffset<
      flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
    >,
  >,
  pub cwd: Option<flatbuffers::WIPOffset<&'a str>>,
  pub env: Option<
    flatbuffers::WIPOffset<
      flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>,
    >,
  >,
  pub stdin: ProcessStdio,
  pub stdout: ProcessStdio,
  pub stderr: ProcessStdio,
  pub stdin_rid: u32,
  pub stdout_rid: u32,
  pub stderr_rid: u32,
}
impl<'a> Default for RunArgs<'a> {
  #[inline]
  fn default() -> Self {
    RunArgs {
      args: None,
      cwd: None,
      env: None,
      stdin: ProcessStdio::Inherit,
      stdout: ProcessStdio::Inherit,
      stderr: ProcessStdio::Inherit,
      stdin_rid: 0,
      stdout_rid: 0,
      stderr_rid: 0,
    }
  }
}
pub struct RunBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RunBuilder<'a, 'b> {
  #[inline]
  pub fn add_args(
    &mut self,
    args: flatbuffers::WIPOffset<
      flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
    >,
  ) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(Run::VT_ARGS, args);
  }
  #[inline]
  pub fn add_cwd(&mut self, cwd: flatbuffers::WIPOffset<&'b str>) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(Run::VT_CWD, cwd);
  }
  #[inline]
  pub fn add_env(
    &mut self,
    env: flatbuffers::WIPOffset<
      flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<KeyValue<'b>>>,
    >,
  ) {
    self
      .fbb_
      .push_slot_always::<flatbuffers::WIPOffset<_>>(Run::VT_ENV, env);
  }
  #[inline]
  pub fn add_stdin(&mut self, stdin: ProcessStdio) {
    self.fbb_.push_slot::<ProcessStdio>(
      Run::VT_STDIN,
      stdin,
      ProcessStdio::Inherit,
    );
  }
  #[inline]
  pub fn add_stdout(&mut self, stdout: ProcessStdio) {
    self.fbb_.push_slot::<ProcessStdio>(
      Run::VT_STDOUT,
      stdout,
      ProcessStdio::Inherit,
    );
  }
  #[inline]
  pub fn add_stderr(&mut self, stderr: ProcessStdio) {
    self.fbb_.push_slot::<ProcessStdio>(
      Run::VT_STDERR,
      stderr,
      ProcessStdio::Inherit,
    );
  }
  #[inline]
  pub fn add_stdin_rid(&mut self, stdin_rid: u32) {
    self.fbb_.push_slot::<u32>(Run::VT_STDIN_RID, stdin_rid, 0);
  }
  #[inline]
  pub fn add_stdout_rid(&mut self, stdout_rid: u32) {
    self
      .fbb_
      .push_slot::<u32>(Run::VT_STDOUT_RID, stdout_rid, 0);
  }
  #[inline]
  pub fn add_stderr_rid(&mut self, stderr_rid: u32) {
    self
      .fbb_
      .push_slot::<u32>(Run::VT_STDERR_RID, stderr_rid, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> RunBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RunBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Run<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RunResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RunRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RunRes<'a> {
  type Inner = RunRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> RunRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RunRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RunResArgs,
  ) -> flatbuffers::WIPOffset<RunRes<'bldr>> {
    let mut builder = RunResBuilder::new(_fbb);
    builder.add_stderr_rid(args.stderr_rid);
    builder.add_stdout_rid(args.stdout_rid);
    builder.add_stdin_rid(args.stdin_rid);
    builder.add_pid(args.pid);
    builder.add_rid(args.rid);
    builder.finish()
  }

  pub const VT_RID: flatbuffers::VOffsetT = 4;
  pub const VT_PID: flatbuffers::VOffsetT = 6;
  pub const VT_STDIN_RID: flatbuffers::VOffsetT = 8;
  pub const VT_STDOUT_RID: flatbuffers::VOffsetT = 10;
  pub const VT_STDERR_RID: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn rid(&self) -> u32 {
    self._tab.get::<u32>(RunRes::VT_RID, Some(0)).unwrap()
  }
  #[inline]
  pub fn pid(&self) -> u32 {
    self._tab.get::<u32>(RunRes::VT_PID, Some(0)).unwrap()
  }
  #[inline]
  pub fn stdin_rid(&self) -> u32 {
    self._tab.get::<u32>(RunRes::VT_STDIN_RID, Some(0)).unwrap()
  }
  #[inline]
  pub fn stdout_rid(&self) -> u32 {
    self
      ._tab
      .get::<u32>(RunRes::VT_STDOUT_RID, Some(0))
      .unwrap()
  }
  #[inline]
  pub fn stderr_rid(&self) -> u32 {
    self
      ._tab
      .get::<u32>(RunRes::VT_STDERR_RID, Some(0))
      .unwrap()
  }
}

pub struct RunResArgs {
  pub rid: u32,
  pub pid: u32,
  pub stdin_rid: u32,
  pub stdout_rid: u32,
  pub stderr_rid: u32,
}
impl<'a> Default for RunResArgs {
  #[inline]
  fn default() -> Self {
    RunResArgs {
      rid: 0,
      pid: 0,
      stdin_rid: 0,
      stdout_rid: 0,
      stderr_rid: 0,
    }
  }
}
pub struct RunResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RunResBuilder<'a, 'b> {
  #[inline]
  pub fn add_rid(&mut self, rid: u32) {
    self.fbb_.push_slot::<u32>(RunRes::VT_RID, rid, 0);
  }
  #[inline]
  pub fn add_pid(&mut self, pid: u32) {
    self.fbb_.push_slot::<u32>(RunRes::VT_PID, pid, 0);
  }
  #[inline]
  pub fn add_stdin_rid(&mut self, stdin_rid: u32) {
    self
      .fbb_
      .push_slot::<u32>(RunRes::VT_STDIN_RID, stdin_rid, 0);
  }
  #[inline]
  pub fn add_stdout_rid(&mut self, stdout_rid: u32) {
    self
      .fbb_
      .push_slot::<u32>(RunRes::VT_STDOUT_RID, stdout_rid, 0);
  }
  #[inline]
  pub fn add_stderr_rid(&mut self, stderr_rid: u32) {
    self
      .fbb_
      .push_slot::<u32>(RunRes::VT_STDERR_RID, stderr_rid, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> RunResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RunResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RunRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RunStatusOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RunStatus<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RunStatus<'a> {
  type Inner = RunStatus<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> RunStatus<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RunStatus { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RunStatusArgs,
  ) -> flatbuffers::WIPOffset<RunStatus<'bldr>> {
    let mut builder = RunStatusBuilder::new(_fbb);
    builder.add_rid(args.rid);
    builder.finish()
  }

  pub const VT_RID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn rid(&self) -> u32 {
    self._tab.get::<u32>(RunStatus::VT_RID, Some(0)).unwrap()
  }
}

pub struct RunStatusArgs {
  pub rid: u32,
}
impl<'a> Default for RunStatusArgs {
  #[inline]
  fn default() -> Self {
    RunStatusArgs { rid: 0 }
  }
}
pub struct RunStatusBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RunStatusBuilder<'a, 'b> {
  #[inline]
  pub fn add_rid(&mut self, rid: u32) {
    self.fbb_.push_slot::<u32>(RunStatus::VT_RID, rid, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> RunStatusBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RunStatusBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RunStatus<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RunStatusResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RunStatusRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RunStatusRes<'a> {
  type Inner = RunStatusRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> RunStatusRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RunStatusRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RunStatusResArgs,
  ) -> flatbuffers::WIPOffset<RunStatusRes<'bldr>> {
    let mut builder = RunStatusResBuilder::new(_fbb);
    builder.add_exit_signal(args.exit_signal);
    builder.add_exit_code(args.exit_code);
    builder.add_got_signal(args.got_signal);
    builder.finish()
  }

  pub const VT_GOT_SIGNAL: flatbuffers::VOffsetT = 4;
  pub const VT_EXIT_CODE: flatbuffers::VOffsetT = 6;
  pub const VT_EXIT_SIGNAL: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn got_signal(&self) -> bool {
    self
      ._tab
      .get::<bool>(RunStatusRes::VT_GOT_SIGNAL, Some(false))
      .unwrap()
  }
  #[inline]
  pub fn exit_code(&self) -> i32 {
    self
      ._tab
      .get::<i32>(RunStatusRes::VT_EXIT_CODE, Some(0))
      .unwrap()
  }
  #[inline]
  pub fn exit_signal(&self) -> i32 {
    self
      ._tab
      .get::<i32>(RunStatusRes::VT_EXIT_SIGNAL, Some(0))
      .unwrap()
  }
}

pub struct RunStatusResArgs {
  pub got_signal: bool,
  pub exit_code: i32,
  pub exit_signal: i32,
}
impl<'a> Default for RunStatusResArgs {
  #[inline]
  fn default() -> Self {
    RunStatusResArgs {
      got_signal: false,
      exit_code: 0,
      exit_signal: 0,
    }
  }
}
pub struct RunStatusResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RunStatusResBuilder<'a, 'b> {
  #[inline]
  pub fn add_got_signal(&mut self, got_signal: bool) {
    self
      .fbb_
      .push_slot::<bool>(RunStatusRes::VT_GOT_SIGNAL, got_signal, false);
  }
  #[inline]
  pub fn add_exit_code(&mut self, exit_code: i32) {
    self
      .fbb_
      .push_slot::<i32>(RunStatusRes::VT_EXIT_CODE, exit_code, 0);
  }
  #[inline]
  pub fn add_exit_signal(&mut self, exit_signal: i32) {
    self
      .fbb_
      .push_slot::<i32>(RunStatusRes::VT_EXIT_SIGNAL, exit_signal, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> RunStatusResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RunStatusResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RunStatusRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum NowOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Now<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Now<'a> {
  type Inner = Now<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Now<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Now { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args NowArgs,
  ) -> flatbuffers::WIPOffset<Now<'bldr>> {
    let mut builder = NowBuilder::new(_fbb);
    builder.finish()
  }
}

pub struct NowArgs {}
impl<'a> Default for NowArgs {
  #[inline]
  fn default() -> Self {
    NowArgs {}
  }
}
pub struct NowBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NowBuilder<'a, 'b> {
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> NowBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NowBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Now<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum NowResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct NowRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NowRes<'a> {
  type Inner = NowRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> NowRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NowRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args NowResArgs,
  ) -> flatbuffers::WIPOffset<NowRes<'bldr>> {
    let mut builder = NowResBuilder::new(_fbb);
    builder.add_seconds(args.seconds);
    builder.add_subsec_nanos(args.subsec_nanos);
    builder.finish()
  }

  pub const VT_SECONDS: flatbuffers::VOffsetT = 4;
  pub const VT_SUBSEC_NANOS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn seconds(&self) -> u64 {
    self._tab.get::<u64>(NowRes::VT_SECONDS, Some(0)).unwrap()
  }
  #[inline]
  pub fn subsec_nanos(&self) -> u32 {
    self
      ._tab
      .get::<u32>(NowRes::VT_SUBSEC_NANOS, Some(0))
      .unwrap()
  }
}

pub struct NowResArgs {
  pub seconds: u64,
  pub subsec_nanos: u32,
}
impl<'a> Default for NowResArgs {
  #[inline]
  fn default() -> Self {
    NowResArgs {
      seconds: 0,
      subsec_nanos: 0,
    }
  }
}
pub struct NowResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NowResBuilder<'a, 'b> {
  #[inline]
  pub fn add_seconds(&mut self, seconds: u64) {
    self.fbb_.push_slot::<u64>(NowRes::VT_SECONDS, seconds, 0);
  }
  #[inline]
  pub fn add_subsec_nanos(&mut self, subsec_nanos: u32) {
    self
      .fbb_
      .push_slot::<u32>(NowRes::VT_SUBSEC_NANOS, subsec_nanos, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> NowResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NowResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NowRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum IsTTYOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct IsTTY<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IsTTY<'a> {
  type Inner = IsTTY<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> IsTTY<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IsTTY { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args IsTTYArgs,
  ) -> flatbuffers::WIPOffset<IsTTY<'bldr>> {
    let mut builder = IsTTYBuilder::new(_fbb);
    builder.finish()
  }
}

pub struct IsTTYArgs {}
impl<'a> Default for IsTTYArgs {
  #[inline]
  fn default() -> Self {
    IsTTYArgs {}
  }
}
pub struct IsTTYBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IsTTYBuilder<'a, 'b> {
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> IsTTYBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IsTTYBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IsTTY<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum IsTTYResOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct IsTTYRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IsTTYRes<'a> {
  type Inner = IsTTYRes<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> IsTTYRes<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IsTTYRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args IsTTYResArgs,
  ) -> flatbuffers::WIPOffset<IsTTYRes<'bldr>> {
    let mut builder = IsTTYResBuilder::new(_fbb);
    builder.add_stderr(args.stderr);
    builder.add_stdout(args.stdout);
    builder.add_stdin(args.stdin);
    builder.finish()
  }

  pub const VT_STDIN: flatbuffers::VOffsetT = 4;
  pub const VT_STDOUT: flatbuffers::VOffsetT = 6;
  pub const VT_STDERR: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn stdin(&self) -> bool {
    self
      ._tab
      .get::<bool>(IsTTYRes::VT_STDIN, Some(false))
      .unwrap()
  }
  #[inline]
  pub fn stdout(&self) -> bool {
    self
      ._tab
      .get::<bool>(IsTTYRes::VT_STDOUT, Some(false))
      .unwrap()
  }
  #[inline]
  pub fn stderr(&self) -> bool {
    self
      ._tab
      .get::<bool>(IsTTYRes::VT_STDERR, Some(false))
      .unwrap()
  }
}

pub struct IsTTYResArgs {
  pub stdin: bool,
  pub stdout: bool,
  pub stderr: bool,
}
impl<'a> Default for IsTTYResArgs {
  #[inline]
  fn default() -> Self {
    IsTTYResArgs {
      stdin: false,
      stdout: false,
      stderr: false,
    }
  }
}
pub struct IsTTYResBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IsTTYResBuilder<'a, 'b> {
  #[inline]
  pub fn add_stdin(&mut self, stdin: bool) {
    self
      .fbb_
      .push_slot::<bool>(IsTTYRes::VT_STDIN, stdin, false);
  }
  #[inline]
  pub fn add_stdout(&mut self, stdout: bool) {
    self
      .fbb_
      .push_slot::<bool>(IsTTYRes::VT_STDOUT, stdout, false);
  }
  #[inline]
  pub fn add_stderr(&mut self, stderr: bool) {
    self
      .fbb_
      .push_slot::<bool>(IsTTYRes::VT_STDERR, stderr, false);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> IsTTYResBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IsTTYResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IsTTYRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum SeekOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Seek<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Seek<'a> {
  type Inner = Seek<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> Seek<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Seek { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SeekArgs,
  ) -> flatbuffers::WIPOffset<Seek<'bldr>> {
    let mut builder = SeekBuilder::new(_fbb);
    builder.add_whence(args.whence);
    builder.add_offset(args.offset);
    builder.add_rid(args.rid);
    builder.finish()
  }

  pub const VT_RID: flatbuffers::VOffsetT = 4;
  pub const VT_OFFSET: flatbuffers::VOffsetT = 6;
  pub const VT_WHENCE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn rid(&self) -> u32 {
    self._tab.get::<u32>(Seek::VT_RID, Some(0)).unwrap()
  }
  #[inline]
  pub fn offset(&self) -> i32 {
    self._tab.get::<i32>(Seek::VT_OFFSET, Some(0)).unwrap()
  }
  #[inline]
  pub fn whence(&self) -> u32 {
    self._tab.get::<u32>(Seek::VT_WHENCE, Some(0)).unwrap()
  }
}

pub struct SeekArgs {
  pub rid: u32,
  pub offset: i32,
  pub whence: u32,
}
impl<'a> Default for SeekArgs {
  #[inline]
  fn default() -> Self {
    SeekArgs {
      rid: 0,
      offset: 0,
      whence: 0,
    }
  }
}
pub struct SeekBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SeekBuilder<'a, 'b> {
  #[inline]
  pub fn add_rid(&mut self, rid: u32) {
    self.fbb_.push_slot::<u32>(Seek::VT_RID, rid, 0);
  }
  #[inline]
  pub fn add_offset(&mut self, offset: i32) {
    self.fbb_.push_slot::<i32>(Seek::VT_OFFSET, offset, 0);
  }
  #[inline]
  pub fn add_whence(&mut self, whence: u32) {
    self.fbb_.push_slot::<u32>(Seek::VT_WHENCE, whence, 0);
  }
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> SeekBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SeekBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Seek<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GetRandomValuesOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GetRandomValues<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetRandomValues<'a> {
  type Inner = GetRandomValues<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self {
      _tab: flatbuffers::Table { buf: buf, loc: loc },
    }
  }
}

impl<'a> GetRandomValues<'a> {
  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetRandomValues { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args GetRandomValuesArgs,
  ) -> flatbuffers::WIPOffset<GetRandomValues<'bldr>> {
    let mut builder = GetRandomValuesBuilder::new(_fbb);
    builder.finish()
  }
}

pub struct GetRandomValuesArgs {}
impl<'a> Default for GetRandomValuesArgs {
  #[inline]
  fn default() -> Self {
    GetRandomValuesArgs {}
  }
}
pub struct GetRandomValuesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetRandomValuesBuilder<'a, 'b> {
  #[inline]
  pub fn new(
    _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  ) -> GetRandomValuesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetRandomValuesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetRandomValues<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_base<'a>(buf: &'a [u8]) -> Base<'a> {
  flatbuffers::get_root::<Base<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_base<'a>(buf: &'a [u8]) -> Base<'a> {
  flatbuffers::get_size_prefixed_root::<Base<'a>>(buf)
}

#[inline]
pub fn finish_base_buffer<'a, 'b>(
  fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  root: flatbuffers::WIPOffset<Base<'a>>,
) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_base_buffer<'a, 'b>(
  fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  root: flatbuffers::WIPOffset<Base<'a>>,
) {
  fbb.finish_size_prefixed(root, None);
}
